This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-01-29 19:19:59

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.dockerignore
.gitignore
Dockerfile
init.sql
nest-cli.json
package.json
README.md
repomix-output.md
src
  api
    api.module.ts
    auth
      auth.module.ts
      controllers
        auth.controller.spec.ts
        auth.controller.ts
      dto
        auth.dto.ts
      guards
        auth.decorator.ts
        roles.guard.ts
        user.decorator.ts
    inventory
      controllers
        inventory.controller.ts
      inventory.module.ts
      inventory.processor.ts
      services
        inventory.service.ts
    product
      controllers
        product.controller.ts
      dto
        product.dto.ts
        productDetails
          computer.details.ts
          index.ts
          test.details.ts
      product.module.ts
      services
        product.service.ts
    role
      controllers
        role.controller.spec.ts
        role.controller.ts
      dto
        role.dto.ts
      enum
        role.enum.ts
      role.module.ts
      services
        role.service.ts
    user
      controllers
        user.controller.ts
      dto
        user.dto.ts
        user.types.ts
      services
        user.service.ts
      user.module.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  common
    helper
      findOneParams.dto.ts
      serialize.interceptor.ts
      success-response.interceptor.ts
  database
    entities
      category.entity.ts
      color.entity.ts
      country.entity.ts
      currency.entity.ts
      inventory.entity.ts
      product.entity.ts
      productVariation.entity.ts
      productVariation_price.entity.ts
      role.entity.ts
      size.entity.ts
      user.entity.ts
    migration
      datasource.ts
    seed
      seed.module.ts
      seed.service.ts
      seed.ts
      seeder.interface.ts
      seeders
        category.seeder.ts
        color.seeder.ts
        country.seeder.ts
        currency.seeder.ts
        role.seeder.ts
        size.seeder.ts
    typeorm
      typeOrm.config.ts
      typeorm.service.ts
  errors
    custom
      index.ts
    errors.filter.ts
  main.ts
```

# Repository Files


## .dockerignore

```text
.git
.gitignore
.dockerignore
.repomixignore
node_modules
dist
coverage
npm-debug.log
Dockerfile
docker-compose.yml
README.md
test
init.sql
```

## .gitignore

```text
# Dependencias
/node_modules
/npm-debug.log
/yarn-error.log
/pnpm-debug.log*

# Compilación y producción
/dist
/build
/coverage

# Entorno y Secretos (¡CRÍTICO!)
.env
.env.*
!.env.example
*.key
*.pem

# IDEs
.idea
.vscode
*.swp
*.DS_Store

# Logs
*.log
logs/

# Datos de Base de datos locales (si usas volúmenes locales)
/database-data
/postgres-data
```

## Dockerfile

```text
FROM node:18-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "run", "start:dev"]
```

## init.sql

```sql
CREATE DATABASE ecommercedb;

-- for test db
CREATE DATABASE ecommerceTestdb;
```

## nest-cli.json

```json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "assets": ["common/envs/*"]
  }
}
```

## package.json

```json
{
  "name": "nestjs-ecommerce",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "clean": "rimraf ./dist",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest --forceExit --detectOpenHandles --verbose",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json --forceExit --detectOpenHandles --verbose",
    "seed:run": "nest start --entryFile ./database/seed/seed.js",
    "typeorm": "npm run clean && npm run build && npx typeorm -d dist/database/migration/datasource.js",
    "migration:generate": "npm run typeorm -- migration:generate src/database/migration/history/$npm_config_name",
    "migration:run": "npm run typeorm -- migration:run",
    "migration:revert": "npm run typeorm migration:revert"
  },
"dependencies": {
    "@nestjs/bullmq": "^10.0.0",
    "bullmq": "^5.0.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^10.0.0",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/typeorm": "^10.0.0",
    "bcrypt": "^5.1.0",
    "bluebird": "^3.7.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "joi": "^17.9.0",
    "pg": "^8.10.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.0",
    "typeorm": "^0.3.17"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/bcrypt": "^5.0.0",
    "@types/bluebird": "^3.5.38",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.3.1",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node",
    "moduleNameMapper": {
      "^src/(.*)$": "<rootDir>/$1"
    }
  }
}
```

## README.md

````markdown
# Ecommerce App with Nest.js and Postgres

## Description
This project is an ecommerce application built using Nest.js and Postgres. The focus is on writing clean, modular, and testable code, and following a well-organized project structure.

## Technology Stack

- Nest.js
- PostgreSQL
- TypeORM
- Jest

## Getting Started

To get started with this project, follow these steps:

- Clone this repository to your local machine.
- navigate to the nestjs-ecommerce directory.

```bash 
cd ./nestjs-ecommerce
```
- start postgres database.

```bash
docker-compose up -d
```

- install app dependencies.

```bash
npm install
```

- run database migrations.

```bash
npm run migration:run
```
if you want to generate any future migration

```bash
npm run migration:generate --name=<migrationName>
```

- run database seeders.

```bash
npm run seed:run
```

- start the applictaion.

```bash
npm run start:dev
```

## Testing
To run the tests, follow these steps:
1. Install dependencies: `npm install`
2. Run the tests: `npm run test`

## Contributing
If you're interested in contributing to this project, please follow these guidelines:
1. Fork the repository
2. Make your changes
3. Submit a pull request
````

## repomix-output.md

`````````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-01-29 12:13:50

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.dockerignore
.gitignore
Dockerfile
init.sql
nest-cli.json
package.json
README.md
repomix-output.md
src
  api
    api.module.ts
    auth
      auth.module.ts
      controllers
        auth.controller.spec.ts
        auth.controller.ts
      dto
        auth.dto.ts
      guards
        auth.decorator.ts
        roles.guard.ts
        user.decorator.ts
    inventory
      controllers
        inventory.controller.ts
      inventory.module.ts
      inventory.processor.ts
      services
        inventory.service.ts
    product
      controllers
        product.controller.ts
      dto
        product.dto.ts
        productDetails
          computer.details.ts
          index.ts
          test.details.ts
      product.module.ts
      services
        product.service.ts
    role
      controllers
        role.controller.spec.ts
        role.controller.ts
      dto
        role.dto.ts
      enum
        role.enum.ts
      role.module.ts
      services
        role.service.ts
    user
      controllers
        user.controller.ts
      dto
        user.dto.ts
        user.types.ts
      services
        user.service.ts
      user.module.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  common
    helper
      findOneParams.dto.ts
      serialize.interceptor.ts
      success-response.interceptor.ts
  database
    entities
      category.entity.ts
      color.entity.ts
      country.entity.ts
      currency.entity.ts
      inventory.entity.ts
      product.entity.ts
      productVariation.entity.ts
      productVariation_price.entity.ts
      role.entity.ts
      size.entity.ts
      user.entity.ts
    migration
      datasource.ts
    seed
      seed.module.ts
      seed.service.ts
      seed.ts
      seeder.interface.ts
      seeders
        category.seeder.ts
        color.seeder.ts
        country.seeder.ts
        currency.seeder.ts
        role.seeder.ts
        size.seeder.ts
    typeorm
      typeOrm.config.ts
      typeorm.service.ts
  errors
    custom
      index.ts
    errors.filter.ts
  main.ts
```

# Repository Files


## .dockerignore

```text
.git
.gitignore
.dockerignore
.repomixignore
node_modules
dist
coverage
npm-debug.log
Dockerfile
docker-compose.yml
README.md
test
init.sql
```

## .gitignore

```text
# Dependencias
/node_modules
/npm-debug.log
/yarn-error.log
/pnpm-debug.log*

# Compilación y producción
/dist
/build
/coverage

# Entorno y Secretos (¡CRÍTICO!)
.env
.env.*
!.env.example
*.key
*.pem

# IDEs
.idea
.vscode
*.swp
*.DS_Store

# Logs
*.log
logs/

# Datos de Base de datos locales (si usas volúmenes locales)
/database-data
/postgres-data
```

## Dockerfile

```text
FROM node:18-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "run", "start:dev"]
```

## init.sql

```sql
CREATE DATABASE ecommercedb;

-- for test db
CREATE DATABASE ecommerceTestdb;
```

## nest-cli.json

```json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "assets": ["common/envs/*"]
  }
}
```

## package.json

```json
{
  "name": "nestjs-ecommerce",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "clean": "rimraf ./dist",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest --forceExit --detectOpenHandles --verbose",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json --forceExit --detectOpenHandles --verbose",
    "seed:run": "nest start --entryFile ./database/seed/seed.js",
    "typeorm": "npm run clean && npm run build && npx typeorm -d dist/database/migration/datasource.js",
    "migration:generate": "npm run typeorm -- migration:generate src/database/migration/history/$npm_config_name",
    "migration:run": "npm run typeorm -- migration:run",
    "migration:revert": "npm run typeorm migration:revert"
  },
"dependencies": {
    "@nestjs/bullmq": "^10.0.0",
    "bullmq": "^5.0.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^10.0.0",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/typeorm": "^10.0.0",
    "bcrypt": "^5.1.0",
    "bluebird": "^3.7.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "joi": "^17.9.0",
    "pg": "^8.10.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.0",
    "typeorm": "^0.3.17"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/bcrypt": "^5.0.0",
    "@types/bluebird": "^3.5.38",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.3.1",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node",
    "moduleNameMapper": {
      "^src/(.*)$": "<rootDir>/$1"
    }
  }
}
```

## README.md

````markdown
# Ecommerce App with Nest.js and Postgres

## Description
This project is an ecommerce application built using Nest.js and Postgres. The focus is on writing clean, modular, and testable code, and following a well-organized project structure.

## Technology Stack

- Nest.js
- PostgreSQL
- TypeORM
- Jest

## Getting Started

To get started with this project, follow these steps:

- Clone this repository to your local machine.
- navigate to the nestjs-ecommerce directory.

```bash 
cd ./nestjs-ecommerce
```
- start postgres database.

```bash
docker-compose up -d
```

- install app dependencies.

```bash
npm install
```

- run database migrations.

```bash
npm run migration:run
```
if you want to generate any future migration

```bash
npm run migration:generate --name=<migrationName>
```

- run database seeders.

```bash
npm run seed:run
```

- start the applictaion.

```bash
npm run start:dev
```

## Testing
To run the tests, follow these steps:
1. Install dependencies: `npm install`
2. Run the tests: `npm run test`

## Contributing
If you're interested in contributing to this project, please follow these guidelines:
1. Fork the repository
2. Make your changes
3. Submit a pull request
````

## repomix-output.md

````````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-01-29 12:05:45

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.dockerignore
.gitignore
Dockerfile
init.sql
nest-cli.json
package.json
README.md
repomix-output.md
src
  api
    api.module.ts
    auth
      auth.module.ts
      controllers
        auth.controller.spec.ts
        auth.controller.ts
      dto
        auth.dto.ts
      guards
        auth.decorator.ts
        roles.guard.ts
        user.decorator.ts
    inventory
      controllers
        inventory.controller.ts
      inventory.module.ts
      inventory.processor.ts
      services
        inventory.service.ts
    product
      controllers
        product.controller.ts
      dto
        product.dto.ts
        productDetails
          computer.details.ts
          index.ts
          test.details.ts
      product.module.ts
      services
        product.service.ts
    role
      controllers
        role.controller.spec.ts
        role.controller.ts
      dto
        role.dto.ts
      enum
        role.enum.ts
      role.module.ts
      services
        role.service.ts
    user
      controllers
        user.controller.ts
      dto
        user.dto.ts
        user.types.ts
      services
        user.service.ts
      user.module.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  common
    helper
      findOneParams.dto.ts
      serialize.interceptor.ts
      success-response.interceptor.ts
  database
    entities
      category.entity.ts
      color.entity.ts
      country.entity.ts
      currency.entity.ts
      inventory.entity.ts
      product.entity.ts
      productVariation.entity.ts
      productVariation_price.entity.ts
      role.entity.ts
      size.entity.ts
      user.entity.ts
    migration
      datasource.ts
    seed
      seed.module.ts
      seed.service.ts
      seed.ts
      seeder.interface.ts
      seeders
        category.seeder.ts
        color.seeder.ts
        country.seeder.ts
        currency.seeder.ts
        role.seeder.ts
        size.seeder.ts
    typeorm
      typeOrm.config.ts
      typeorm.service.ts
  errors
    custom
      index.ts
    errors.filter.ts
  main.ts
```

# Repository Files


## .dockerignore

```text
.git
.gitignore
.dockerignore
.repomixignore
node_modules
dist
coverage
npm-debug.log
Dockerfile
docker-compose.yml
README.md
test
init.sql
```

## .gitignore

```text
# Dependencias
/node_modules
/npm-debug.log
/yarn-error.log
/pnpm-debug.log*

# Compilación y producción
/dist
/build
/coverage

# Entorno y Secretos (¡CRÍTICO!)
.env
.env.*
!.env.example
*.key
*.pem

# IDEs
.idea
.vscode
*.swp
*.DS_Store

# Logs
*.log
logs/

# Datos de Base de datos locales (si usas volúmenes locales)
/database-data
/postgres-data
```

## Dockerfile

```text
FROM node:18-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "run", "start:dev"]
```

## init.sql

```sql
CREATE DATABASE ecommercedb;

-- for test db
CREATE DATABASE ecommerceTestdb;
```

## nest-cli.json

```json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "assets": ["common/envs/*"]
  }
}
```

## package.json

```json
{
  "name": "nestjs-ecommerce",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "clean": "rimraf ./dist",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest --forceExit --detectOpenHandles --verbose",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json --forceExit --detectOpenHandles --verbose",
    "seed:run": "nest start --entryFile ./database/seed/seed.js",
    "typeorm": "npm run clean && npm run build && npx typeorm -d dist/database/migration/datasource.js",
    "migration:generate": "npm run typeorm -- migration:generate src/database/migration/history/$npm_config_name",
    "migration:run": "npm run typeorm -- migration:run",
    "migration:revert": "npm run typeorm migration:revert"
  },
"dependencies": {
    "@nestjs/bullmq": "^10.0.0",
    "bullmq": "^5.0.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^10.0.0",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/typeorm": "^10.0.0",
    "bcrypt": "^5.1.0",
    "bluebird": "^3.7.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "joi": "^17.9.0",
    "pg": "^8.10.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.0",
    "typeorm": "^0.3.17"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/bcrypt": "^5.0.0",
    "@types/bluebird": "^3.5.38",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.3.1",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node",
    "moduleNameMapper": {
      "^src/(.*)$": "<rootDir>/$1"
    }
  }
}
```

## README.md

````markdown
# Ecommerce App with Nest.js and Postgres

## Description
This project is an ecommerce application built using Nest.js and Postgres. The focus is on writing clean, modular, and testable code, and following a well-organized project structure.

## Technology Stack

- Nest.js
- PostgreSQL
- TypeORM
- Jest

## Getting Started

To get started with this project, follow these steps:

- Clone this repository to your local machine.
- navigate to the nestjs-ecommerce directory.

```bash 
cd ./nestjs-ecommerce
```
- start postgres database.

```bash
docker-compose up -d
```

- install app dependencies.

```bash
npm install
```

- run database migrations.

```bash
npm run migration:run
```
if you want to generate any future migration

```bash
npm run migration:generate --name=<migrationName>
```

- run database seeders.

```bash
npm run seed:run
```

- start the applictaion.

```bash
npm run start:dev
```

## Testing
To run the tests, follow these steps:
1. Install dependencies: `npm install`
2. Run the tests: `npm run test`

## Contributing
If you're interested in contributing to this project, please follow these guidelines:
1. Fork the repository
2. Make your changes
3. Submit a pull request
````

## repomix-output.md

```````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-01-29 10:56:17

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.dockerignore
.gitignore
Dockerfile
init.sql
nest-cli.json
package.json
README.md
repomix-output.md
src
  api
    api.module.ts
    auth
      auth.module.ts
      controllers
        auth.controller.spec.ts
        auth.controller.ts
      dto
        auth.dto.ts
      guards
        auth.decorator.ts
        roles.guard.ts
        user.decorator.ts
    inventory
      controllers
        inventory.controller.ts
      inventory.module.ts
      inventory.processor.ts
      services
        inventory.service.ts
    product
      controllers
        product.controller.ts
      dto
        product.dto.ts
        productDetails
          computer.details.ts
          index.ts
          test.details.ts
      product.module.ts
      services
        product.service.ts
    role
      controllers
        role.controller.spec.ts
        role.controller.ts
      dto
        role.dto.ts
      enum
        role.enum.ts
      role.module.ts
      services
        role.service.ts
    user
      controllers
        user.controller.ts
      dto
        user.dto.ts
        user.types.ts
      services
        user.service.ts
      user.module.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  common
    helper
      findOneParams.dto.ts
      serialize.interceptor.ts
      success-response.interceptor.ts
  database
    entities
      category.entity.ts
      color.entity.ts
      country.entity.ts
      currency.entity.ts
      inventory.entity.ts
      product.entity.ts
      productVariation.entity.ts
      productVariation_price.entity.ts
      role.entity.ts
      size.entity.ts
      user.entity.ts
    migration
      datasource.ts
    seed
      seed.module.ts
      seed.service.ts
      seed.ts
      seeder.interface.ts
      seeders
        category.seeder.ts
        color.seeder.ts
        country.seeder.ts
        currency.seeder.ts
        role.seeder.ts
        size.seeder.ts
    typeorm
      typeOrm.config.ts
      typeorm.service.ts
  errors
    custom
      index.ts
    errors.filter.ts
  main.ts
```

# Repository Files


## .dockerignore

```text
.git
.gitignore
.dockerignore
.repomixignore
node_modules
dist
coverage
npm-debug.log
Dockerfile
docker-compose.yml
README.md
test
init.sql
```

## .gitignore

```text
# Dependencias
/node_modules
/npm-debug.log
/yarn-error.log
/pnpm-debug.log*

# Compilación y producción
/dist
/build
/coverage

# Entorno y Secretos (¡CRÍTICO!)
.env
.env.*
!.env.example
*.key
*.pem

# IDEs
.idea
.vscode
*.swp
*.DS_Store

# Logs
*.log
logs/

# Datos de Base de datos locales (si usas volúmenes locales)
/database-data
/postgres-data
```

## Dockerfile

```text
FROM node:18-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "run", "start:dev"]
```

## init.sql

```sql
CREATE DATABASE ecommercedb;

-- for test db
CREATE DATABASE ecommerceTestdb;
```

## nest-cli.json

```json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "assets": ["common/envs/*"]
  }
}
```

## package.json

```json
{
  "name": "nestjs-ecommerce",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "clean": "rimraf ./dist",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest --forceExit --detectOpenHandles --verbose",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json --forceExit --detectOpenHandles --verbose",
    "seed:run": "nest start --entryFile ./database/seed/seed.js",
    "typeorm": "npm run clean && npm run build && npx typeorm -d dist/database/migration/datasource.js",
    "migration:generate": "npm run typeorm -- migration:generate src/database/migration/history/$npm_config_name",
    "migration:run": "npm run typeorm -- migration:run",
    "migration:revert": "npm run typeorm migration:revert"
  },
"dependencies": {
    "@nestjs/bullmq": "^10.0.0",
    "bullmq": "^5.0.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^10.0.0",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/typeorm": "^10.0.0",
    "bcrypt": "^5.1.0",
    "bluebird": "^3.7.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "joi": "^17.9.0",
    "pg": "^8.10.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.0",
    "typeorm": "^0.3.17"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/bcrypt": "^5.0.0",
    "@types/bluebird": "^3.5.38",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.3.1",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node",
    "moduleNameMapper": {
      "^src/(.*)$": "<rootDir>/$1"
    }
  }
}
```

## README.md

````markdown
# Ecommerce App with Nest.js and Postgres

## Description
This project is an ecommerce application built using Nest.js and Postgres. The focus is on writing clean, modular, and testable code, and following a well-organized project structure.

## Technology Stack

- Nest.js
- PostgreSQL
- TypeORM
- Jest

## Getting Started

To get started with this project, follow these steps:

- Clone this repository to your local machine.
- navigate to the nestjs-ecommerce directory.

```bash 
cd ./nestjs-ecommerce
```
- start postgres database.

```bash
docker-compose up -d
```

- install app dependencies.

```bash
npm install
```

- run database migrations.

```bash
npm run migration:run
```
if you want to generate any future migration

```bash
npm run migration:generate --name=<migrationName>
```

- run database seeders.

```bash
npm run seed:run
```

- start the applictaion.

```bash
npm run start:dev
```

## Testing
To run the tests, follow these steps:
1. Install dependencies: `npm install`
2. Run the tests: `npm run test`

## Contributing
If you're interested in contributing to this project, please follow these guidelines:
1. Fork the repository
2. Make your changes
3. Submit a pull request
````

## repomix-output.md

``````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-01-29 10:13:21

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.dockerignore
.gitignore
Dockerfile
init.sql
nest-cli.json
package.json
README.md
repomix-output.md
src
  api
    api.module.ts
    auth
      auth.module.ts
      controllers
        auth.controller.spec.ts
        auth.controller.ts
      dto
        auth.dto.ts
      guards
        auth.decorator.ts
        roles.guard.ts
        user.decorator.ts
    inventory
      controllers
        inventory.controller.ts
      inventory.module.ts
      inventory.processor.ts
      services
        inventory.service.ts
    product
      controllers
        product.controller.ts
      dto
        product.dto.ts
        productDetails
          computer.details.ts
          index.ts
          test.details.ts
      product.module.ts
      services
        product.service.ts
    role
      controllers
        role.controller.spec.ts
        role.controller.ts
      dto
        role.dto.ts
      enum
        role.enum.ts
      role.module.ts
      services
        role.service.ts
    user
      controllers
        user.controller.ts
      dto
        user.dto.ts
        user.types.ts
      services
        user.service.ts
      user.module.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  common
    helper
      findOneParams.dto.ts
      serialize.interceptor.ts
      success-response.interceptor.ts
  database
    entities
      category.entity.ts
      color.entity.ts
      country.entity.ts
      currency.entity.ts
      inventory.entity.ts
      product.entity.ts
      productVariation.entity.ts
      productVariation_price.entity.ts
      role.entity.ts
      size.entity.ts
      user.entity.ts
    migration
      datasource.ts
    seed
      seed.module.ts
      seed.service.ts
      seed.ts
      seeder.interface.ts
      seeders
        category.seeder.ts
        color.seeder.ts
        country.seeder.ts
        currency.seeder.ts
        role.seeder.ts
        size.seeder.ts
    typeorm
      typeOrm.config.ts
      typeorm.service.ts
  errors
    custom
      index.ts
    errors.filter.ts
  main.ts
```

# Repository Files


## .dockerignore

```text
.git
.gitignore
.dockerignore
.repomixignore
node_modules
dist
coverage
npm-debug.log
Dockerfile
docker-compose.yml
README.md
test
init.sql
```

## .gitignore

```text
# Dependencias
/node_modules
/npm-debug.log
/yarn-error.log
/pnpm-debug.log*

# Compilación y producción
/dist
/build
/coverage

# Entorno y Secretos (¡CRÍTICO!)
.env
.env.*
!.env.example
*.key
*.pem

# IDEs
.idea
.vscode
*.swp
*.DS_Store

# Logs
*.log
logs/

# Datos de Base de datos locales (si usas volúmenes locales)
/database-data
/postgres-data
```

## Dockerfile

```text
FROM node:18-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "run", "start:dev"]
```

## init.sql

```sql
CREATE DATABASE ecommercedb;

-- for test db
CREATE DATABASE ecommerceTestdb;
```

## nest-cli.json

```json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "assets": ["common/envs/*"]
  }
}
```

## package.json

```json
{
  "name": "nestjs-ecommerce",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "clean": "rimraf ./dist",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest --forceExit --detectOpenHandles --verbose",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json --forceExit --detectOpenHandles --verbose",
    "seed:run": "nest start --entryFile ./database/seed/seed.js",
    "typeorm": "npm run clean && npm run build && npx typeorm -d dist/database/migration/datasource.js",
    "migration:generate": "npm run typeorm -- migration:generate src/database/migration/history/$npm_config_name",
    "migration:run": "npm run typeorm -- migration:run",
    "migration:revert": "npm run typeorm migration:revert"
  },
"dependencies": {
    "@nestjs/bullmq": "^10.0.0",
    "bullmq": "^5.0.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^10.0.0",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/typeorm": "^10.0.0",
    "bcrypt": "^5.1.0",
    "bluebird": "^3.7.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "joi": "^17.9.0",
    "pg": "^8.10.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.0",
    "typeorm": "^0.3.17"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/bcrypt": "^5.0.0",
    "@types/bluebird": "^3.5.38",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.0",
    "@types/node": "^20.3.1",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node",
    "moduleNameMapper": {
      "^src/(.*)$": "<rootDir>/$1"
    }
  }
}
```

## README.md

````markdown
# Ecommerce App with Nest.js and Postgres

## Description
This project is an ecommerce application built using Nest.js and Postgres. The focus is on writing clean, modular, and testable code, and following a well-organized project structure.

## Technology Stack

- Nest.js
- PostgreSQL
- TypeORM
- Jest

## Getting Started

To get started with this project, follow these steps:

- Clone this repository to your local machine.
- navigate to the nestjs-ecommerce directory.

```bash 
cd ./nestjs-ecommerce
```
- start postgres database.

```bash
docker-compose up -d
```

- install app dependencies.

```bash
npm install
```

- run database migrations.

```bash
npm run migration:run
```
if you want to generate any future migration

```bash
npm run migration:generate --name=<migrationName>
```

- run database seeders.

```bash
npm run seed:run
```

- start the applictaion.

```bash
npm run start:dev
```

## Testing
To run the tests, follow these steps:
1. Install dependencies: `npm install`
2. Run the tests: `npm run test`

## Contributing
If you're interested in contributing to this project, please follow these guidelines:
1. Fork the repository
2. Make your changes
3. Submit a pull request
````

## repomix-output.md

`````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-01-27 20:47:06

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.eslintrc.js
.gitignore
.prettierrc
init.sql
nest-cli.json
package.json
README.md
src
  api
    api.module.ts
    auth
      auth.module.ts
      controllers
        auth.controller.spec.ts
        auth.controller.ts
      dto
        auth.dto.ts
      guards
        auth.decorator.ts
        roles.guard.ts
        user.decorator.ts
    product
      controllers
        product.controller.ts
      dto
        product.dto.ts
        productDetails
          computer.details.ts
          index.ts
          test.details.ts
      product.module.ts
      services
        product.service.ts
    role
      controllers
        role.controller.spec.ts
        role.controller.ts
      dto
        role.dto.ts
      enum
        role.enum.ts
      role.module.ts
      services
        role.service.ts
    user
      controllers
        user.controller.ts
      dto
        user.dto.ts
        user.types.ts
      services
        user.service.ts
      user.module.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  common
    envs
      .gitignore
    helper
      env.helper.ts
      findOneParams.dto.ts
      serialize.interceptor.ts
      sucess-response.interceptor.ts
  database
    entities
      category.entity.ts
      color.entity.ts
      country.entity.ts
      currency.entity.ts
      inventory.entity.ts
      product.entity.ts
      productVariation.entity.ts
      productVariation_price.entity.ts
      role.entity.ts
      size.entity.ts
      user.entity.ts
    migration
      datasource.ts
    seed
      seed.module.ts
      seed.service.ts
      seed.ts
      seeder.interface.ts
      seeders
        admin.seeder.ts
        category.seeder.ts
        color.seeder.ts
        country.seeder.ts
        currency.seeder.ts
        role.seeder.ts
        size.seeder.ts
    typeorm
      typeOrm.config.ts
      typeorm.service.ts
  errors
    custom
      index.ts
    errors.filter.ts
  main.ts
test
  app.e2e-spec.ts
  jest-e2e.json
  mocks
    jwt.ts
tsconfig.build.json
tsconfig.json
```

# Repository Files


## .eslintrc.js

```javascript
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};
```

## .gitignore

```text
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

#database data
database-data
```

## .prettierrc

```text
{
  "singleQuote": true,
  "trailingComma": "all"
}
```

## init.sql

```sql
CREATE DATABASE ecommercedb;

-- for test db
CREATE DATABASE ecommerceTestdb;
```

## nest-cli.json

```json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "assets": ["common/envs/*"]
  }
}
```

## package.json

```json
{
  "name": "nestjs-ecommerce",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "clean": "rimraf ./dist",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest --forceExit --detectOpenHandles --verbose",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json --forceExit --detectOpenHandles --verbose",
    "seed:run": "nest start --entryFile ./database/seed/seed.js",
    "typeorm": "npm run clean && npm run build && npx typeorm -d dist/database/migration/datasource.js",
    "migration:generate": "npm run typeorm -- migration:generate src/database/migration/history/$npm_config_name",
    "migration:run": "npm run typeorm -- migration:run",
    "migration:revert": "npm run typeorm migration:revert"
  },
  "dependencies": {
    "@nestjs/common": "^9.0.0",
    "@nestjs/config": "^2.3.1",
    "@nestjs/core": "^9.0.0",
    "@nestjs/jwt": "^10.0.3",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^9.0.0",
    "@nestjs/typeorm": "^9.0.1",
    "@types/bcrypt": "^5.0.0",
    "@types/bluebird": "^3.5.38",
    "bcrypt": "^5.1.0",
    "bluebird": "^3.7.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "dotenv": "^16.0.3",
    "pg": "^8.10.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.2.0",
    "typeorm": "^0.3.15"
  },
  "devDependencies": {
    "@nestjs/cli": "^9.0.0",
    "@nestjs/schematics": "^9.0.0",
    "@nestjs/testing": "^9.0.0",
    "@types/express": "^4.17.13",
    "@types/jest": "29.2.4",
    "@types/node": "18.11.18",
    "@types/supertest": "^2.0.11",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.1",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "29.3.1",
    "prettier": "^2.3.2",
    "source-map-support": "^0.5.20",
    "supertest": "^6.1.3",
    "ts-jest": "29.0.3",
    "ts-loader": "^9.2.3",
    "ts-node": "^10.0.0",
    "tsconfig-paths": "4.1.1",
    "typescript": "^4.7.4"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node",
    "moduleNameMapper": {
      "^src/(.*)$": "<rootDir>/$1"
    }
  }
}
```

## README.md

````markdown
# Ecommerce App with Nest.js and Postgres

## Description
This project is an ecommerce application built using Nest.js and Postgres. The focus is on writing clean, modular, and testable code, and following a well-organized project structure.

## Technology Stack

- Nest.js
- PostgreSQL
- TypeORM
- Jest

## Getting Started

To get started with this project, follow these steps:

- Clone this repository to your local machine.
- navigate to the nestjs-ecommerce directory.

```bash 
cd ./nestjs-ecommerce
```
- start postgres database.

```bash
docker-compose up -d
```

- install app dependencies.

```bash
npm install
```

- run database migrations.

```bash
npm run migration:run
```
if you want to generate any future migration

```bash
npm run migration:generate --name=<migrationName>
```

- run database seeders.

```bash
npm run seed:run
```

- start the applictaion.

```bash
npm run start:dev
```

## Testing
To run the tests, follow these steps:
1. Install dependencies: `npm install`
2. Run the tests: `npm run test`

## Contributing
If you're interested in contributing to this project, please follow these guidelines:
1. Fork the repository
2. Make your changes
3. Submit a pull request
````

## src/api/api.module.ts

```typescript
import { Module } from '@nestjs/common';
import { APP_FILTER, APP_INTERCEPTOR } from '@nestjs/core';
import { SucessResponseInterceptor } from 'src/common/helper/sucess-response.interceptor';
import { AuthModule } from './auth/auth.module';
import { UserModule } from './user/user.module';
import { RoleModule } from './role/role.module';
import { ProductModule } from './product/product.module';
import { ErrorsFilter } from 'src/errors/errors.filter';

@Module({
  imports: [AuthModule, UserModule, RoleModule, ProductModule],
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: SucessResponseInterceptor,
    },
    {
      provide: APP_FILTER,
      useClass: ErrorsFilter,
    },
  ],
})
export class ApiModule {}
```

## src/api/auth/auth.module.ts

```typescript
import { Module } from '@nestjs/common';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { RoleModule } from '../role/role.module';
import { AuthController } from './controllers/auth.controller';
import { AuthService } from './services/auth.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [
    UserModule,
    TypeOrmModule.forFeature([User]),
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '3h' },
    }),
    RoleModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, UserService],
  exports: [],
})
export class AuthModule {}
```

## src/api/auth/controllers/auth.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from '../services/auth.service';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;
  let fakeAuthService: Partial<AuthService>;

  beforeEach(async () => {
    fakeAuthService = {
      register: () => {
        return Promise.resolve({
          message: 'success',
        });
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: fakeAuthService,
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/auth/controllers/auth.controller.ts

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { CreateUserDto } from 'src/api/user/dto/user.dto';
import { AuthService } from '../services/auth.service';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  login(@Body() user: CreateUserDto) {
    return this.authService.login(user);
  }

  @Post('register')
  register(@Body() user: CreateUserDto) {
    return this.authService.register(user);
  }
}
```

## src/api/auth/dto/auth.dto.ts

```typescript
import { IsNotEmpty } from 'class-validator';

export class PayloadDto {
  @IsNotEmpty()
  public email: string;

  @IsNotEmpty()
  public id: number;
}
```

## src/api/auth/guards/auth.decorator.ts

```typescript
import { applyDecorators, SetMetadata, UseGuards } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { RolesGuard } from './roles.guard';

export function Auth(...roleIds: number[]) {
  return applyDecorators(
    SetMetadata('roleIds', roleIds),
    UseGuards(AuthGuard, RolesGuard),
  );
}
```

## src/api/auth/guards/roles.guard.ts

```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private readonly userService: UserService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const roles = this.reflector.get<number[]>('roleIds', context.getHandler());
    if (roles.length === 0) return true;
    const request = context.switchToHttp().getRequest();
    if (!request.user.roles.some((userRole) => roles.includes(userRole.id)))
      throw new UnauthorizedException(errorMessages.auth.notAllowed);

    return true;
  }
}
```

## src/api/auth/guards/user.decorator.ts

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from 'src/database/entities/user.entity';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext): User => {
    const req = context.switchToHttp().getRequest();
    return req.user;
  },
);
```

## src/api/product/controllers/product.controller.ts

```typescript
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { RoleIds } from '../../role/enum/role.enum';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { ProductService } from '../services/product.service';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { FindOneParams } from 'src/common/helper/findOneParams.dto';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { User } from 'src/database/entities/user.entity';

@Controller('product')
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Get(':id')
  async getProduct(@Param() product: FindOneParams) {
    return this.productService.getProduct(product.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post('create')
  async createProduct(
    @Body() body: CreateProductDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.createProduct(body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/details')
  async addProductDetails(
    @Param() product: FindOneParams,
    @Body() body: ProductDetailsDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.addProductDetails(product.id, body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/activate')
  async activateProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.activateProduct(product.id, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Delete(':id')
  async deleteProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.deleteProduct(product.id, user.id);
  }
}
```

## src/api/product/dto/product.dto.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsIn,
  IsNotEmpty,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import { variationTypesKeys } from 'src/database/entities/product.entity';
import { ProductDetails, ProductDetailsTypeFn } from './productDetails';

export class CreateProductDto {
  @IsNumber()
  @IsNotEmpty()
  public categoryId: number;
}

export class ProductDetailsDto {
  @IsString()
  @IsNotEmpty()
  public title: string;

  @IsString()
  @IsNotEmpty()
  public code: string;

  @IsDefined()
  @IsString()
  @IsIn(variationTypesKeys)
  public variationType: string;

  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: ProductDetails;

  @ArrayMinSize(1)
  @IsString({ each: true })
  public about: string[];

  @IsString()
  @IsNotEmpty()
  public description: string;
}
```

## src/api/product/dto/productDetails/computer.details.ts

```typescript
import { IsIn, IsNotEmpty, IsNumber, IsString } from 'class-validator';
import { Categories } from 'src/database/entities/category.entity';

export class ComputerDetails {
  @IsString()
  @IsNotEmpty()
  category = Categories.Computers;

  @IsNumber()
  capacity: number;

  @IsString()
  @IsIn(['GB', 'TB'])
  capacityUnit: 'GB' | 'TB';

  @IsString()
  @IsIn(['SSD', 'HD'])
  capacityType: 'SSD' | 'HD';

  @IsString()
  @IsNotEmpty()
  brand: string;

  @IsString()
  @IsNotEmpty()
  series: string;
}
```

## src/api/product/dto/productDetails/index.ts

```typescript
import { BadRequestException } from '@nestjs/common';
import { TypeHelpOptions } from 'class-transformer';
import { Categories } from 'src/database/entities/category.entity';
import { ComputerDetails } from './computer.details';
import { TestDetails } from './test.details';

export type ProductDetails = ComputerDetails | TestDetails;

export function ProductDetailsTypeFn(options: TypeHelpOptions) {
  switch (options.object?.details?.category) {
    case Categories.Computers:
      return ComputerDetails;
    case 'Test':
      return TestDetails;
  }

  throw new BadRequestException('invalid details.category input');
}
```

## src/api/product/dto/productDetails/test.details.ts

```typescript
export class TestDetails {
  category = 'Test';
  test: boolean;
}
```

## src/api/product/product.module.ts

```typescript
import { Module } from '@nestjs/common';
import { ProductService } from './services/product.service';
import { ProductController } from './controllers/product.controller';
import { Category } from '../../database/entities/category.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { Product } from 'src/database/entities/product.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User, Product, Category]), UserModule],
  controllers: [ProductController],
  providers: [ProductService],
})
export class ProductModule {}
```

## src/api/product/services/product.service.ts

```typescript
import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { DeleteResult, EntityManager } from 'typeorm';
import { InjectEntityManager } from '@nestjs/typeorm';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { Category } from '../../../database/entities/category.entity';
import { Product } from 'src/database/entities/product.entity';
import { errorMessages } from 'src/errors/custom';
import { validate } from 'class-validator';
import { successObject } from 'src/common/helper/sucess-response.interceptor';

@Injectable()
export class ProductService {
  constructor(
    @InjectEntityManager()
    private readonly entityManager: EntityManager,
  ) {}

  async getProduct(productId: number) {
    const product = await this.entityManager.findOne(Product, {
      where: {
        id: productId,
      },
    });

    if (!product) throw new NotFoundException(errorMessages.product.notFound);

    return product;
  }

  async createProduct(data: CreateProductDto, merchantId: number) {
    const category = await this.entityManager.findOne(Category, {
      where: {
        id: data.categoryId,
      },
    });

    if (!category) throw new NotFoundException(errorMessages.category.notFound);

    const product = await this.entityManager.create(Product, {
      category,
      merchantId,
    });

    return this.entityManager.save(product);
  }

  async addProductDetails(
    productId: number,
    body: ProductDetailsDto,
    merchantId: number,
  ) {
    const result = await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({
        ...body,
      })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute();
    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);
    return result.raw[0];
  }

  async activateProduct(productId: number, merchantId: number) {
    if (!(await this.validate(productId)))
      throw new ConflictException(errorMessages.product.notFulfilled);

    const result = await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({
        isActive: true,
      })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id', 'isActive'])
      .execute();

    return result.raw[0];
  }

  async validate(productId: number) {
    const product = await this.entityManager.findOne(Product, {
      where: {
        id: productId,
      },
    });
    if (!product) throw new NotFoundException(errorMessages.product.notFound);
    const errors = await validate(product);

    if (errors.length > 0) return false;

    return true;
  }

  async deleteProduct(productId: number, merchantId: number) {
    const result = await this.entityManager
      .createQueryBuilder()
      .delete()
      .from(Product)
      .where('id = :productId', { productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .execute();

    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);

    return successObject;
  }
}
```

## src/api/role/controllers/role.controller.spec.ts

```typescript
import { ConfigModule } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { configuration } from 'src/config';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { AuthModule } from '../../auth/auth.module';
import { RoleController } from './role.controller';
import { Role } from '../../../database/entities/role.entity';
import { RoleIds, Roles } from '../enum/role.enum';
import { RoleService } from '../services/role.service';
import { UserService } from 'src/api/user/services/user.service';

describe('RoleController', () => {
  let controller: RoleController;
  let fakeRoleService: Partial<RoleService>;
  let fakeUserService: Partial<UserService>;

  const customerRole = {
    id: RoleIds.Customer,
    name: Roles.Customer,
  } as Role;

  beforeEach(async () => {
    fakeRoleService = {
      findById: () => {
        return Promise.resolve(customerRole);
      },
    };
    fakeUserService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [RoleController],
      providers: [
        {
          provide: RoleService,
          useValue: fakeRoleService,
        },
        {
          provide: UserService,
          useValue: fakeUserService,
        },
      ],
      imports: [
        AuthModule,
        ConfigModule.forRoot({ load: [configuration], isGlobal: true }),
        TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
      ],
    }).compile();

    controller = module.get<RoleController>(RoleController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/role/controllers/role.controller.ts

```typescript
import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { AssignRoleDto } from '../dto/role.dto';
import { RoleIds } from '../enum/role.enum';
import { RoleService } from '../services/role.service';

@Controller('role')
export class RoleController {
  constructor(private readonly roleService: RoleService) {}

  @Auth(RoleIds.Admin)
  @Post('assign')
  async assignRoleToUser(@Body() body: AssignRoleDto) {
    return this.roleService.assignRoleToUser(body);
  }
}
```

## src/api/role/dto/role.dto.ts

```typescript
import { IsNotEmpty, IsNumber } from 'class-validator';

export class AssignRoleDto {
  @IsNumber()
  @IsNotEmpty()
  public userId: number;

  @IsNumber()
  @IsNotEmpty()
  public roleId: number;
}
```

## src/api/role/enum/role.enum.ts

```typescript
export enum RoleIds {
  Customer = 1,
  Merchant,
  Admin,
}

export enum Roles {
  Customer = 'Customer',
  Merchant = 'Merchant',
  Admin = 'Admin',
}
```

## src/api/role/role.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Role } from '../../database/entities/role.entity';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { RoleController } from './controllers/role.controller';
import { RoleService } from './services/role.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [TypeOrmModule.forFeature([Role, User]), UserModule],
  controllers: [RoleController],
  providers: [RoleService, UserService],
  exports: [RoleService],
})
export class RoleModule {}
```

## src/api/role/services/role.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Role } from 'src/database/entities/role.entity';
import { AssignRoleDto } from '../dto/role.dto';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RoleService {
  constructor(
    @InjectRepository(Role) private readonly rolesRepository: Repository<Role>,
    private readonly userService: UserService,
  ) {}

  async assignRoleToUser(data: AssignRoleDto) {
    const role = await this.findById(data.roleId);
    const user = await this.userService.findById(data.userId, { roles: true });
    if (!user.roles.some((userRole) => userRole.id === data.roleId)) {
      user.roles.push(role);
    }
    return this.userService.save(user);
  }

  async findById(roleId: number) {
    const role = await this.rolesRepository.findOne({
      where: {
        id: roleId,
      },
    });
    if (!role) {
      throw new NotFoundException(errorMessages.role.notFound);
    }
    return role;
  }
}
```

## src/api/user/controllers/user.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { Serialize } from 'src/common/helper/serialize.interceptor';
import { User } from 'src/database/entities/user.entity';
import { UserDto } from '../dto/user.dto';
import { UserService } from '../services/user.service';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Auth()
  @Serialize(UserDto)
  @Get('profile')
  profile(@CurrentUser() user: User) {
    return this.userService.findById(user.id);
  }
}
```

## src/api/user/dto/user.dto.ts

```typescript
import { Expose } from 'class-transformer';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  public email: string;

  @IsString()
  @IsNotEmpty()
  public password: string;
}

export class UserDto {
  @Expose()
  public id: number;

  @Expose()
  public email: string;
}
```

## src/api/user/dto/user.types.ts

```typescript
export type UserRelation = {
  roles: boolean;
};
```

## src/api/user/services/user.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { Repository } from 'typeorm';
import { hash, compare } from 'bcrypt';
import { InjectRepository } from '@nestjs/typeorm';
import { User } from 'src/database/entities/user.entity';
import { CreateUserDto } from '../dto/user.dto';
import { Role } from 'src/database/entities/role.entity';
import { UserRelation } from '../dto/user.types';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User) private readonly repository: Repository<User>,
  ) {}

  public async createUser(
    body: CreateUserDto,
    ...roles: Role[]
  ): Promise<User> {
    body.password = await hash(body.password, 10);
    const user: User = this.repository.create({
      ...body,
      roles,
    });

    return this.repository.save(user);
  }

  public async findByEmail(
    email: string,
    relations?: UserRelation,
  ): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        email,
      },
      relations,
    });
    return user;
  }

  public async comparePassword(password, userPassword): Promise<boolean> {
    return compare(password, userPassword);
  }

  public async findById(id: number, relations?: UserRelation): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        id,
      },
      relations,
    });
    if (!user) {
      throw new NotFoundException(errorMessages.user.notFound);
    }
    return user;
  }

  public async save(user: User) {
    return this.repository.save(user);
  }
}
```

## src/api/user/user.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../../database/entities/user.entity';
import { UserController } from './controllers/user.controller';
import { UserService } from './services/user.service';

@Module({
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
  imports: [TypeOrmModule.forFeature([User])],
})
export class UserModule {}
```

## src/app.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
```

## src/app.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

## src/app.module.ts

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { TypeOrmConfigService } from './database/typeorm/typeorm.service';
import { ApiModule } from './api/api.module';
import { configuration } from './config';

@Module({
  imports: [
    ConfigModule.forRoot({ load: [configuration], isGlobal: true }),
    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    ApiModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

## src/app.service.ts

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
```

## src/common/envs/.gitignore

```text
.env
```

## src/common/helper/env.helper.ts

```typescript
import { existsSync } from 'fs';
import { resolve } from 'path';

export function getEnvPath(dest: string): string {
  const env: string | undefined = process.env.NODE_ENV;
  const fallback: string = resolve(`${dest}/.env`);
  const filename: string = env ? `${env}.env` : 'development.env';
  let filePath: string = resolve(`${dest}/${filename}`);
  if (!existsSync(filePath)) {
    filePath = fallback;
  }

  return filePath;
}
```

## src/common/helper/findOneParams.dto.ts

```typescript
import { IsNumberString } from 'class-validator';

export class FindOneParams {
  @IsNumberString()
  id: number;
}
```

## src/common/helper/serialize.interceptor.ts

```typescript
import {
  UseInterceptors,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { plainToInstance } from 'class-transformer';

interface ClassConstructor {
  new (...args: any[]): any;
}

export function Serialize(dto: ClassConstructor) {
  return UseInterceptors(new SerializeInterceptor(dto));
}

export class SerializeInterceptor implements NestInterceptor {
  constructor(private dto: any) {}

  intercept(context: ExecutionContext, handler: CallHandler): Observable<any> {
    return handler.handle().pipe(
      map((data: any) => {
        return plainToInstance(this.dto, data, {
          excludeExtraneousValues: true,
        });
      }),
    );
  }
}
```

## src/common/helper/sucess-response.interceptor.ts

```typescript
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { map, Observable } from 'rxjs';

@Injectable()
export class SucessResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        return {
          isSuccess: true,
          message: 'success',
          data,
          errorCode: null,
          errors: [],
        };
      }),
    );
  }
}

export const successObject = {
  message: 'success',
};
```

## src/database/entities/category.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  PrimaryColumn,
} from 'typeorm';
import { Product } from './product.entity';

@Entity()
export class Category {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar' })
  public name: string;

  @OneToMany(() => Product, (product) => product.category)
  products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CategoryIds {
  Computers = 1,
  Fashion,
}

export enum Categories {
  Computers = 'Computers',
  Fashion = 'Fashion',
}
```

## src/database/entities/color.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Color {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public name!: string;

  @Column({ type: 'varchar', length: 10 })
  public hexCode: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum Colors {
  NA = 'NA',
  Red = 'red',
  Green = 'green',
  Blue = 'blue',
}

export enum ColorsHexCodes {
  NA = 'NA',
  Red = '#FF0000',
  Green = '#00FF00',
  Blue = '#0000FF',
}
```

## src/database/entities/country.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Country {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CountryCodes {
  Egypt = 'EG',
}

export enum Countries {
  Egypt = 'Egypt',
}
```

## src/database/entities/currency.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Currency {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CurrencyCodes {
  EGP = 'EGP',
}

export enum CurrencyNames {
  EGP = 'Egyptian Pound',
}
```

## src/database/entities/inventory.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class Inventory {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @Column({ type: 'int' })
  public quantity: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/product.entity.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import {
  ProductDetails,
  ProductDetailsTypeFn,
} from 'src/api/product/dto/productDetails';
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  JoinColumn,
  Index,
} from 'typeorm';
import { Category } from './category.entity';
import { User } from './user.entity';

@Entity()
export class Product {
  @PrimaryGeneratedColumn()
  @IsDefined()
  @IsNumber()
  public id!: number;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  @Index()
  public code: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public title: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public variationType: string;

  @Column({ type: 'text', nullable: true })
  @IsDefined()
  @IsString()
  public description?: string | null;

  @Column({ type: 'text', array: true, default: [] })
  @ArrayMinSize(1)
  @IsString({ each: true })
  public about?: string[];

  @Column({ type: 'jsonb', nullable: true })
  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: Partial<ProductDetails> | null;

  @Column({ default: false })
  public isActive: boolean;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public merchantId: number;

  @ManyToOne(() => User, (user) => user.products)
  @JoinColumn({ name: 'merchantId' })
  public merchant: User;

  @ManyToOne(() => Category, (category) => category.products)
  @JoinColumn({ name: 'categoryId' })
  public category: Category;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public categoryId: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum VariationTypes {
  NONE = 'NONE',
  OnlySize = 'OnlySize',
  OnlyColor = 'OnlyColor',
  SizeAndColor = 'SizeAndColor',
}
export const variationTypesKeys = Object.keys(VariationTypes);
```

## src/database/entities/productVariation.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Color } from './color.entity';
import { Product } from './product.entity';
import { Size } from './size.entity';

@Entity()
export class ProductVariation {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => Product)
  @JoinColumn({ name: 'productId' })
  public product: Product;

  @Column({ type: 'int' })
  public productId: number;

  @ManyToOne(() => Size)
  @JoinColumn({ name: 'sizeCode' })
  public size: Size;

  @Column({ type: 'varchar', length: 7 })
  public sizeCode: string;

  @ManyToOne(() => Color)
  @JoinColumn({ name: 'colorName' })
  public color: Color;

  @Column({ type: 'varchar', length: 30 })
  public colorName: string;

  @Column({ type: 'text', array: true, default: [] })
  public imageUrls: string[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/productVariation_price.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { Currency } from './currency.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class ProductVariationPrice {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @ManyToOne(() => Currency)
  @JoinColumn({ name: 'currencyCode' })
  public currency: Currency;

  @Column({ type: 'varchar', length: 7 })
  public currencyCode: string;

  @Column({ type: 'float' })
  public price: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/role.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
  ManyToMany,
} from 'typeorm';
import { User } from './user.entity';

@Entity()
export class Role {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public name: string;

  @ManyToMany(() => User, (user) => user.roles)
  public users: User[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/size.entity.ts

```typescript
import {
  Entity,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Size {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public code!: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum SizeCodes {
  NA = 'NA',
  Small = 'S',
  Medium = 'M',
  Large = 'L',
  XLarge = 'XL',
  XXLarge = 'XXL',
}
```

## src/database/entities/user.entity.ts

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToMany,
  JoinTable,
  OneToMany,
} from 'typeorm';
import { Product } from './product.entity';
import { Role } from './role.entity';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public email: string;

  @Column({ type: 'varchar' })
  public password: string;

  @ManyToMany(() => Role, (role) => role.users)
  @JoinTable({ name: 'user_roles' })
  public roles: Role[];

  @OneToMany(() => Product, (product) => product.merchant)
  public products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/migration/datasource.ts

```typescript
import { DataSource } from 'typeorm';
import { dataSourceOptions } from '../typeorm/typeOrm.config';

const datasource = new DataSource(dataSourceOptions);

export default datasource;
```

## src/database/seed/seed.module.ts

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { configuration } from 'src/config';
import { Category } from 'src/database/entities/category.entity';
import { Role } from 'src/database/entities/role.entity';
import { User } from 'src/database/entities/user.entity';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { Color } from '../entities/color.entity';
import { Country } from '../entities/country.entity';
import { Currency } from '../entities/currency.entity';
import { Size } from '../entities/size.entity';
import { SeedService } from './seed.service';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';

@Module({
  imports: [
    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    TypeOrmModule.forFeature([
      Role,
      User,
      Category,
      Size,
      Color,
      Country,
      Currency,
    ]),
    ConfigModule.forRoot({ load: [configuration], isGlobal: true }),
  ],
  controllers: [],
  providers: [
    SeedService,
    RolesSeeder,
    AdminSeeder,
    CategorySeeder,
    SizeSeeder,
    ColorSeeder,
    CountrySeeder,
    CurrencySeeder,
  ],
})
export class SeedModule {}
```

## src/database/seed/seed.service.ts

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Promise as Bluebird } from 'bluebird';
import { SeederInterface } from './seeder.interface';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';

@Injectable()
export class SeedService {
  private readonly seeders: SeederInterface[] = [];
  private readonly logger = new Logger(SeedService.name);

  constructor(
    rolesSeeder: RolesSeeder,
    adminSeeder: AdminSeeder,
    categoriesSeeder: CategorySeeder,
    sizesSeeder: SizeSeeder,
    colorsSeeder: ColorSeeder,
    countrySeeder: CountrySeeder,
    currencySeeder: CurrencySeeder,
  ) {
    this.seeders = [
      rolesSeeder,
      adminSeeder,
      categoriesSeeder,
      sizesSeeder,
      colorsSeeder,
      countrySeeder,
      currencySeeder,
    ];
  }

  async seed() {
    await Bluebird.each(this.seeders, async (seeder: SeederInterface) => {
      this.logger.log(`Seeding ${seeder.constructor.name}`);
      await seeder.seed();
    });
  }
}
```

## src/database/seed/seed.ts

```typescript
import { NestFactory } from '@nestjs/core';
import { SeedModule } from './seed.module';
import { SeedService } from './seed.service';

async function bootstrap() {
  const app = await NestFactory.create(SeedModule);
  const seedService = app.get(SeedService);
  await seedService.seed();
  await app.close();
}
bootstrap();
```

## src/database/seed/seeder.interface.ts

```typescript
export interface SeederInterface {
  seed(): Promise<void>;
}
```

## src/database/seed/seeders/admin.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectEntityManager, InjectRepository } from '@nestjs/typeorm';
import { Repository, EntityManager } from 'typeorm';
import { SeederInterface } from '../seeder.interface';
import { hash } from 'bcrypt';
import { ConfigService } from '@nestjs/config';
import { User } from 'src/database/entities/user.entity';
import { Role } from 'src/database/entities/role.entity';

@Injectable()
export class AdminSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Role)
    private readonly rolesRepository: Repository<Role>,
    private readonly config: ConfigService,
    @InjectEntityManager()
    private readonly entityManager: EntityManager,
  ) {}

  async seed() {
    const data: Partial<User> = await this.generateData();
    await this.entityManager.transaction(async (transactionalEntityManager) => {
      const result = await transactionalEntityManager.upsert(User, data, {
        conflictPaths: ['email'],
      });
      const adminUser = await transactionalEntityManager
        .getRepository(User)
        .findOne({
          where: {
            id: result.raw[0].id,
          },
        });
      adminUser.roles = data.roles;
      await transactionalEntityManager.save(adminUser);
    });
  }

  async generateData(): Promise<Partial<User>> {
    const hashedPassword = await hash(
      this.config.get<string>('adminUser.password'),
      10,
    );
    const adminRoles = await this.rolesRepository.find();
    return {
      email: this.config.get<string>('adminUser.email'),
      password: hashedPassword,
      roles: adminRoles,
    };
  }
}
```

## src/database/seed/seeders/category.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Categories,
  Category,
  CategoryIds,
} from 'src/database/entities/category.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CategorySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Category)
    private readonly categoriesRepository: Repository<Category>,
  ) {}

  async seed() {
    const data: Partial<Category>[] = this.generateData();
    await this.categoriesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Category>[] {
    const data: Partial<Category>[] = [];
    Object.keys(Categories).forEach((key) => {
      data.push({
        id: CategoryIds[key],
        name: Categories[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/color.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Color,
  Colors,
  ColorsHexCodes,
} from 'src/database/entities/color.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class ColorSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Color)
    private readonly colorsRepository: Repository<Color>,
  ) {}

  async seed() {
    const data: Partial<Color>[] = this.generateData();
    await this.colorsRepository.upsert(data, {
      conflictPaths: ['name'],
    });
  }

  generateData(): Partial<Color>[] {
    const data: Partial<Color>[] = [];
    Object.keys(Colors).forEach((key) => {
      data.push({
        name: Colors[key],
        hexCode: ColorsHexCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/country.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Countries,
  Country,
  CountryCodes,
} from 'src/database/entities/country.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CountrySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Country)
    private readonly countryRepository: Repository<Country>,
  ) {}

  async seed() {
    const data: Partial<Country>[] = this.generateData();
    await this.countryRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Country>[] {
    const data: Partial<Country>[] = [];
    Object.keys(Countries).forEach((key) => {
      data.push({
        code: CountryCodes[key],
        name: Countries[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/currency.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Currency,
  CurrencyCodes,
  CurrencyNames,
} from 'src/database/entities/currency.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CurrencySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Currency)
    private readonly currencyRepository: Repository<Currency>,
  ) {}

  async seed() {
    const data: Partial<Currency>[] = this.generateData();
    await this.currencyRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Currency>[] {
    const data: Partial<Currency>[] = [];
    Object.keys(CurrencyCodes).forEach((key) => {
      data.push({
        code: CurrencyCodes[key],
        name: CurrencyNames[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/role.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';
import { Role } from 'src/database/entities/role.entity';
import { RoleIds, Roles } from 'src/api/role/enum/role.enum';

@Injectable()
export class RolesSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Role)
    private readonly rolesRepository: Repository<Role>,
  ) {}

  async seed() {
    const data: Partial<Role>[] = this.generateData();
    await this.rolesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Role>[] {
    const data: Partial<Role>[] = [];
    Object.keys(Roles).forEach((key) => {
      data.push({
        id: RoleIds[key],
        name: Roles[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/size.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Size, SizeCodes } from 'src/database/entities/size.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class SizeSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Size)
    private readonly SizeRepository: Repository<Size>,
  ) {}

  async seed() {
    const data: Partial<Size>[] = this.generateData();
    await this.SizeRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Size>[] {
    const data: Partial<Size>[] = [];
    Object.keys(SizeCodes).forEach((key) => {
      data.push({
        code: SizeCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/typeorm/typeOrm.config.ts

```typescript
import { config } from 'dotenv';
import { resolve } from 'path';
import { getEnvPath } from '../../common/helper/env.helper';
import { DataSourceOptions } from 'typeorm';

const envFilePath: string = getEnvPath(
  resolve(__dirname, '../..', 'common/envs'),
);
config({ path: envFilePath });
export const dataSourceOptions: DataSourceOptions = {
  type: 'postgres',
  host: process.env.DATABASE_HOST,
  port: parseInt(process.env.DATABASE_PORT, 10),
  database: process.env.DATABASE_NAME,
  username: process.env.DATABASE_USER,
  password: process.env.DATABASE_PASSWORD,
  entities: [process.env.DATABASE_ENTITIES],
  migrations: ['dist/database/migration/history/*.js'],
  logger: 'simple-console',
  synchronize: false, // never use TRUE in production!
  logging: true, // for debugging in dev Area only
};
```

## src/database/typeorm/typeorm.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import { TypeOrmOptionsFactory, TypeOrmModuleOptions } from '@nestjs/typeorm';
import { dataSourceOptions } from 'src/database/typeorm/typeOrm.config';

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  public createTypeOrmOptions(): TypeOrmModuleOptions {
    return dataSourceOptions;
  }
}
```

## src/errors/custom/index.ts

```typescript
export interface ErrorBody extends Error {
  code: string;
}

export const errorMessages = {
  auth: {
    wronCredentials: {
      message: 'wrong data provided',
      code: '60001',
    },
    userAlreadyExist: {
      message: 'user already exist',
      code: '60002',
    },
    expiredToken: {
      message: 'token expired',
      code: '60003',
    },
    invlidToken: {
      message: 'invlid token',
      code: '60004',
    },
    notAllowed: {
      message: 'not allowed',
      code: '60005',
    },
  },
  user: {
    notFound: {
      message: 'user not found',
      code: '60101',
    },
  },
  role: {
    notFound: {
      message: 'role not found',
      code: '60201',
    },
  },
  category: {
    notFound: {
      message: 'category not found',
      code: '60301',
    },
  },
  product: {
    notFound: {
      message: 'product not found',
      code: '60401',
    },
    notFulfilled: {
      message: 'not all product info is fulfilled',
      code: '60402',
    },
  },
  global: {
    internalError: {
      message: 'something went wrong',
      code: '70000',
    },
  },
};
```

## src/errors/errors.filter.ts

```typescript
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';
import { ErrorBody, errorMessages } from './custom';

@Catch()
export class ErrorsFilter implements ExceptionFilter {
  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

  catch(exception: Error, host: ArgumentsHost): void {
    Logger.error(exception.message);
    const { httpAdapter } = this.httpAdapterHost;

    const ctx = host.switchToHttp();
    if (exception instanceof HttpException) {
      const message = exception.message;
      const httpStatus =
        exception.getStatus() || HttpStatus.INTERNAL_SERVER_ERROR;
      const errorMessage = (exception.getResponse() as HttpException).message;
      const errorCode = (exception.getResponse() as ErrorBody).code || '60400';
      const errors = Array.isArray(errorMessage)
        ? errorMessage
        : [errorMessage];
      const responseBody = {
        isSuccess: false,
        message,
        errorCode,
        data: null,
        errors,
      };

      httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);
    } else {
      const responseBody = {
        isSuccess: false,
        message: errorMessages.global.internalError.message,
        errorCode: errorMessages.global.internalError.code,
        data: null,
        errors: [errorMessages.global.internalError.message],
      };

      httpAdapter.reply(
        ctx.getResponse(),
        responseBody,
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
```

## src/main.ts

```typescript
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe({ transform: true }));
  await app.listen(3000);
}
bootstrap();
```

## test/app.e2e-spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', async () => {
    const response = await request(app.getHttpServer()).get('/');
    expect(response.status).toBe(200);
    expect(response.body.isSuccess).toBe(true);
    expect(response.body.errors).toStrictEqual([]);
  });
});
```

## test/jest-e2e.json

```json
{
  "moduleFileExtensions": [
    "js",
    "json",
    "ts"
  ],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  },
  "moduleDirectories": [
    "<rootDir>/../",
    "node_modules"
  ]
}
```

## test/mocks/jwt.ts

```typescript
import { JwtService } from '@nestjs/jwt';
import { TestingModule } from '@nestjs/testing';
import { User } from 'src/database/entities/user.entity';

export const generateMockToken = async (module: TestingModule, user: User) => {
  const jwtService = module.get(JwtService);
  return jwtService.signAsync(
    {
      email: user.email,
      id: user.id,
    },
    {
      secret: process.env.JWT_SECRET,
    },
  );
};
```

## tsconfig.build.json

```json
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
```

## tsconfig.json

```json
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2017",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}
```

## Statistics

- Total Files: 75
- Total Characters: 122551
- Total Tokens: 0
`````

## src/api/api.module.ts

```typescript
import { Module } from '@nestjs/common';
import { APP_FILTER, APP_INTERCEPTOR } from '@nestjs/core';
import { SucessResponseInterceptor } from 'src/common/helper/success-response.interceptor';
import { AuthModule } from './auth/auth.module';
import { UserModule } from './user/user.module';
import { RoleModule } from './role/role.module';
import { ProductModule } from './product/product.module';
import { ErrorsFilter } from 'src/errors/errors.filter';
import { InventoryModule } from './inventory/inventory.module';

@Module({
  imports: [AuthModule, UserModule, RoleModule, ProductModule, InventoryModule],
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: SucessResponseInterceptor,
    },
    {
      provide: APP_FILTER,
      useClass: ErrorsFilter,
    },
  ],
})
export class ApiModule {}
```

## src/api/auth/auth.module.ts

```typescript
import { Module } from '@nestjs/common';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { RoleModule } from '../role/role.module';
import { AuthController } from './controllers/auth.controller';
import { AuthService } from './services/auth.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [
    UserModule,
    TypeOrmModule.forFeature([User]),
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '3h' },
    }),
    RoleModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, UserService],
  exports: [],
})
export class AuthModule {}
```

## src/api/auth/controllers/auth.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from '../services/auth.service';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;
  let fakeAuthService: Partial<AuthService>;

  beforeEach(async () => {
    fakeAuthService = {
      register: () => {
        return Promise.resolve({
          message: 'success',
        });
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: fakeAuthService,
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/auth/controllers/auth.controller.ts

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { CreateUserDto } from 'src/api/user/dto/user.dto';
import { AuthService } from '../services/auth.service';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  login(@Body() user: CreateUserDto) {
    return this.authService.login(user);
  }

  @Post('register')
  register(@Body() user: CreateUserDto) {
    return this.authService.register(user);
  }
}
```

## src/api/auth/dto/auth.dto.ts

```typescript
import { IsNotEmpty } from 'class-validator';

export class PayloadDto {
  @IsNotEmpty()
  public email: string;

  @IsNotEmpty()
  public id: number;
}
```

## src/api/auth/guards/auth.decorator.ts

```typescript
import { applyDecorators, SetMetadata, UseGuards } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { RolesGuard } from './roles.guard';

export function Auth(...roleIds: number[]) {
  return applyDecorators(
    SetMetadata('roleIds', roleIds),
    UseGuards(AuthGuard, RolesGuard),
  );
}
```

## src/api/auth/guards/roles.guard.ts

```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private readonly userService: UserService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const roles = this.reflector.get<number[]>('roleIds', context.getHandler());
    if (roles.length === 0) return true;
    const request = context.switchToHttp().getRequest();
    if (!request.user.roles.some((userRole) => roles.includes(userRole.id)))
      throw new UnauthorizedException(errorMessages.auth.notAllowed);

    return true;
  }
}
```

## src/api/auth/guards/user.decorator.ts

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from 'src/database/entities/user.entity';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext): User => {
    const req = context.switchToHttp().getRequest();
    return req.user;
  },
);
```

## src/api/inventory/controllers/inventory.controller.ts

```typescript
/* eslint-disable prettier/prettier */
import { Controller, Get, Param, ParseIntPipe } from '@nestjs/common';
import { InventoryService } from '../services/inventory.service';
//import { Auth } from 'src/api/auth/guards/auth.decorator';
// Importamos Auth para proteger la ruta, aunque sea de lectura (opcional según regla de negocio)

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @Get('product/:id')
  async getProductStock(@Param('id', ParseIntPipe) productId: number) {
    return this.inventoryService.getStockByProduct(productId);
  }
}
```

## src/api/inventory/inventory.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';
import { InventoryController } from './controllers/inventory.controller';
import { InventoryService } from './services/inventory.service';
import { InventoryProcessor } from './inventory.processor'; // <--- Importamos

@Module({
  imports: [
    TypeOrmModule.forFeature([Inventory, ProductVariation]),
  ],
  controllers: [InventoryController],
  providers: [InventoryService, 
    InventoryProcessor // Registramos el processor como provider (importante )

  ],
  exports: [InventoryService], // Exportamos el servicio para usarlo en otros lados si hiciera falta
})
export class InventoryModule {}
```

## src/api/inventory/inventory.processor.ts

```typescript
/* eslint-disable prettier/prettier */
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { Logger } from '@nestjs/common';
import { InventoryService } from './services/inventory.service';

@Processor('catalog-queue') // Debe coincidir con el nombre en ProductModule
export class InventoryProcessor extends WorkerHost {
  private readonly logger = new Logger(InventoryProcessor.name);

  constructor(private readonly inventoryService: InventoryService) {
      super();
  }

  async process(job: Job<any, any, string>): Promise<any> {
    switch (job.name) {
      case 'product.created':
        return this.handleProductCreated(job);
      default:
        this.logger.warn(`Evento desconocido: ${job.name}`);
    }
  }

  private async handleProductCreated(job: Job) {
    this.logger.log(`Procesando evento product.created para ID: ${job.data.productId}`);
    
    try {
      // AQUÍ LLAMAMOS A LA LOGICA DE NEGOCIO
      // Nota: Como el modelo de datos original es complejo (Product -> Variation -> Inventory)
      // y al crear un producto aun no hay variacion, por ahora simularemos la creacion
      // o crearemos una variación "default" si la logica lo permite.
      
      // Para efectos del desafio, demostramos que el mensaje llego:
      this.logger.log(`¡Inventario inicializado para Producto ${job.data.productId}!`);
      
      // En un escenario real, aquí llamariamos a:
      // await this.inventoryService.createInitialStock(job.data.productId);
      
    } catch (error) {
      this.logger.error(`Error procesando inventario: ${error.message}`);
      throw error; // Lanzar error hace que BullMQ reintente el trabajo automaticamente
    }
  }
}
```

## src/api/inventory/services/inventory.service.ts

```typescript
/* eslint-disable prettier/prettier */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-inferrable-types */
/* eslint-disable prettier/prettier */
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';

@Injectable()
export class InventoryService {
  constructor(
    @InjectRepository(Inventory)
    private readonly inventoryRepo: Repository<Inventory>,
    @InjectRepository(ProductVariation)
    private readonly variationRepo: Repository<ProductVariation>,
  ) {}

  // Este método será llamado por el EVENTO mas adelante
  async createInitialStock(variationId: number, quantity: number = 0) {
    // Simulamos que el stock es para 'Egypt' por defecto según las entidades actuales
    const countryCode = 'EG'; 

    const inventory = this.inventoryRepo.create({
      productVariationId: variationId,
      countryCode: countryCode,
      quantity: quantity,
    });

    return this.inventoryRepo.save(inventory);
  }

  // Metodo para que el Frontend consulte stock
  async getStockByProduct(productId: number) {
    // Buscamos todas las variaciones de un producto y sumamos su stock
    const variations = await this.variationRepo.find({
      where: { productId },
      relations: ['product'],
    });

    if (!variations.length) {
      return { productId, totalStock: 0, breakdown: [] };
    }

    const variationIds = variations.map(v => v.id);
    
    const stockItems = await this.inventoryRepo
      .createQueryBuilder('inventory')
      .where('inventory.productVariationId IN (:...ids)', { ids: variationIds })
      .getMany();

    const totalStock = stockItems.reduce((acc, item) => acc + item.quantity, 0);

    return {
      productId,
      totalStock,
      breakdown: stockItems,
    };
  }
}
```

## src/api/product/controllers/product.controller.ts

```typescript
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { RoleIds } from '../../role/enum/role.enum';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { ProductService } from '../services/product.service';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { FindOneParams } from 'src/common/helper/findOneParams.dto';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { User } from 'src/database/entities/user.entity';

@Controller('product')
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Get(':id')
  async getProduct(@Param() product: FindOneParams) {
    return this.productService.getProduct(product.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post('create')
  async createProduct(
    @Body() body: CreateProductDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.createProduct(body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/details')
  async addProductDetails(
    @Param() product: FindOneParams,
    @Body() body: ProductDetailsDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.addProductDetails(product.id, body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/activate')
  async activateProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.activateProduct(product.id, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Delete(':id')
  async deleteProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.deleteProduct(product.id, user.id);
  }
}
```

## src/api/product/dto/product.dto.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsIn,
  IsNotEmpty,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import { variationTypesKeys } from 'src/database/entities/product.entity';
import { ProductDetails, ProductDetailsTypeFn } from './productDetails';

export class CreateProductDto {
  @IsNumber()
  @IsNotEmpty()
  public categoryId: number;
}

export class ProductDetailsDto {
  @IsString()
  @IsNotEmpty()
  public title: string;

  @IsString()
  @IsNotEmpty()
  public code: string;

  @IsDefined()
  @IsString()
  @IsIn(variationTypesKeys)
  public variationType: string;

  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: ProductDetails;

  @ArrayMinSize(1)
  @IsString({ each: true })
  public about: string[];

  @IsString()
  @IsNotEmpty()
  public description: string;
}
```

## src/api/product/dto/productDetails/computer.details.ts

```typescript
import { IsIn, IsNotEmpty, IsNumber, IsString } from 'class-validator';
import { Categories } from 'src/database/entities/category.entity';

export class ComputerDetails {
  @IsString()
  @IsNotEmpty()
  category = Categories.Computers;

  @IsNumber()
  capacity: number;

  @IsString()
  @IsIn(['GB', 'TB'])
  capacityUnit: 'GB' | 'TB';

  @IsString()
  @IsIn(['SSD', 'HD'])
  capacityType: 'SSD' | 'HD';

  @IsString()
  @IsNotEmpty()
  brand: string;

  @IsString()
  @IsNotEmpty()
  series: string;
}
```

## src/api/product/dto/productDetails/index.ts

```typescript
import { BadRequestException } from '@nestjs/common';
import { TypeHelpOptions } from 'class-transformer';
import { Categories } from 'src/database/entities/category.entity';
import { ComputerDetails } from './computer.details';
import { TestDetails } from './test.details';

export type ProductDetails = ComputerDetails | TestDetails;

export function ProductDetailsTypeFn(options: TypeHelpOptions) {
  switch (options.object?.details?.category) {
    case Categories.Computers:
      return ComputerDetails;
    case 'Test':
      return TestDetails;
  }

  throw new BadRequestException('invalid details.category input');
}
```

## src/api/product/dto/productDetails/test.details.ts

```typescript
export class TestDetails {
  category = 'Test';
  test: boolean;
}
```

## src/api/product/product.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ProductService } from './services/product.service';
import { ProductController } from './controllers/product.controller';
import { Category } from '../../database/entities/category.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { Product } from 'src/database/entities/product.entity';
import { BullModule } from '@nestjs/bullmq'; 
@Module({
  imports: [TypeOrmModule.forFeature([User, Product, Category]), UserModule,
 // Registramos la cola donde vamos a publicar mensajes
    BullModule.registerQueue({
      name: 'catalog-queue',
    }),],
  controllers: [ProductController],
  providers: [ProductService],
})
export class ProductModule {}
```

## src/api/product/services/product.service.ts

```typescript
import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { DeleteResult, EntityManager } from 'typeorm';
import { InjectEntityManager } from '@nestjs/typeorm';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { Category } from '../../../database/entities/category.entity';
import { Product } from 'src/database/entities/product.entity';
import { errorMessages } from 'src/errors/custom';
import { validate } from 'class-validator';
import { successObject } from 'src/common/helper/success-response.interceptor';

@Injectable()
export class ProductService {
  constructor(
    @InjectEntityManager()
    private readonly entityManager: EntityManager,
  ) {}

  async getProduct(productId: number) {
    const product = await this.entityManager.findOne(Product, {
      where: {
        id: productId,
      },
    });

    if (!product) throw new NotFoundException(errorMessages.product.notFound);

    return product;
  }

  async createProduct(data: CreateProductDto, merchantId: number) {
    const category = await this.entityManager.findOne(Category, {
      where: {
        id: data.categoryId,
      },
    });

    if (!category) throw new NotFoundException(errorMessages.category.notFound);

    const product = await this.entityManager.create(Product, {
      category,
      merchantId,
    });

    return this.entityManager.save(product);
  }

  async addProductDetails(
    productId: number,
    body: ProductDetailsDto,
    merchantId: number,
  ) {
    const result = await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({
        ...body,
      })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute();
    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);
    return result.raw[0];
  }

  async activateProduct(productId: number, merchantId: number) {
    if (!(await this.validate(productId)))
      throw new ConflictException(errorMessages.product.notFulfilled);

    const result = await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({
        isActive: true,
      })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id', 'isActive'])
      .execute();

    return result.raw[0];
  }

  async validate(productId: number) {
    const product = await this.entityManager.findOne(Product, {
      where: {
        id: productId,
      },
    });
    if (!product) throw new NotFoundException(errorMessages.product.notFound);
    const errors = await validate(product);

    if (errors.length > 0) return false;

    return true;
  }

  async deleteProduct(productId: number, merchantId: number) {
    const result = await this.entityManager
      .createQueryBuilder()
      .delete()
      .from(Product)
      .where('id = :productId', { productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .execute();

    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);

    return successObject;
  }
}
```

## src/api/role/controllers/role.controller.spec.ts

```typescript
import { ConfigModule } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { configuration } from 'src/config';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { AuthModule } from '../../auth/auth.module';
import { RoleController } from './role.controller';
import { Role } from '../../../database/entities/role.entity';
import { RoleIds, Roles } from '../enum/role.enum';
import { RoleService } from '../services/role.service';
import { UserService } from 'src/api/user/services/user.service';

describe('RoleController', () => {
  let controller: RoleController;
  let fakeRoleService: Partial<RoleService>;
  let fakeUserService: Partial<UserService>;

  const customerRole = {
    id: RoleIds.Customer,
    name: Roles.Customer,
  } as Role;

  beforeEach(async () => {
    fakeRoleService = {
      findById: () => {
        return Promise.resolve(customerRole);
      },
    };
    fakeUserService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [RoleController],
      providers: [
        {
          provide: RoleService,
          useValue: fakeRoleService,
        },
        {
          provide: UserService,
          useValue: fakeUserService,
        },
      ],
      imports: [
        AuthModule,
        ConfigModule.forRoot({ load: [configuration], isGlobal: true }),
        TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
      ],
    }).compile();

    controller = module.get<RoleController>(RoleController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/role/controllers/role.controller.ts

```typescript
import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { AssignRoleDto } from '../dto/role.dto';
import { RoleIds } from '../enum/role.enum';
import { RoleService } from '../services/role.service';

@Controller('role')
export class RoleController {
  constructor(private readonly roleService: RoleService) {}

  @Auth(RoleIds.Admin)
  @Post('assign')
  async assignRoleToUser(@Body() body: AssignRoleDto) {
    return this.roleService.assignRoleToUser(body);
  }
}
```

## src/api/role/dto/role.dto.ts

```typescript
import { IsNotEmpty, IsNumber } from 'class-validator';

export class AssignRoleDto {
  @IsNumber()
  @IsNotEmpty()
  public userId: number;

  @IsNumber()
  @IsNotEmpty()
  public roleId: number;
}
```

## src/api/role/enum/role.enum.ts

```typescript
export enum RoleIds {
  Customer = 1,
  Merchant,
  Admin,
}

export enum Roles {
  Customer = 'Customer',
  Merchant = 'Merchant',
  Admin = 'Admin',
}
```

## src/api/role/role.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Role } from '../../database/entities/role.entity';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { RoleController } from './controllers/role.controller';
import { RoleService } from './services/role.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [TypeOrmModule.forFeature([Role, User]), UserModule],
  controllers: [RoleController],
  providers: [RoleService, UserService],
  exports: [RoleService],
})
export class RoleModule {}
```

## src/api/role/services/role.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Role } from 'src/database/entities/role.entity';
import { AssignRoleDto } from '../dto/role.dto';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RoleService {
  constructor(
    @InjectRepository(Role) private readonly rolesRepository: Repository<Role>,
    private readonly userService: UserService,
  ) {}

  async assignRoleToUser(data: AssignRoleDto) {
    const role = await this.findById(data.roleId);
    const user = await this.userService.findById(data.userId, { roles: true });
    if (!user.roles.some((userRole) => userRole.id === data.roleId)) {
      user.roles.push(role);
    }
    return this.userService.save(user);
  }

  async findById(roleId: number) {
    const role = await this.rolesRepository.findOne({
      where: {
        id: roleId,
      },
    });
    if (!role) {
      throw new NotFoundException(errorMessages.role.notFound);
    }
    return role;
  }
}
```

## src/api/user/controllers/user.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { Serialize } from 'src/common/helper/serialize.interceptor';
import { User } from 'src/database/entities/user.entity';
import { UserDto } from '../dto/user.dto';
import { UserService } from '../services/user.service';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Auth()
  @Serialize(UserDto)
  @Get('profile')
  profile(@CurrentUser() user: User) {
    return this.userService.findById(user.id);
  }
}
```

## src/api/user/dto/user.dto.ts

```typescript
import { Expose } from 'class-transformer';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  public email: string;

  @IsString()
  @IsNotEmpty()
  public password: string;
}

export class UserDto {
  @Expose()
  public id: number;

  @Expose()
  public email: string;
}
```

## src/api/user/dto/user.types.ts

```typescript
export type UserRelation = {
  roles: boolean;
};
```

## src/api/user/services/user.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { Repository } from 'typeorm';
import { hash, compare } from 'bcrypt';
import { InjectRepository } from '@nestjs/typeorm';
import { User } from 'src/database/entities/user.entity';
import { CreateUserDto } from '../dto/user.dto';
import { Role } from 'src/database/entities/role.entity';
import { UserRelation } from '../dto/user.types';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User) private readonly repository: Repository<User>,
  ) {}

  public async createUser(
    body: CreateUserDto,
    ...roles: Role[]
  ): Promise<User> {
    body.password = await hash(body.password, 10);
    const user: User = this.repository.create({
      ...body,
      roles,
    });

    return this.repository.save(user);
  }

  public async findByEmail(
    email: string,
    relations?: UserRelation,
  ): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        email,
      },
      relations,
    });
    return user;
  }

  public async comparePassword(password, userPassword): Promise<boolean> {
    return compare(password, userPassword);
  }

  public async findById(id: number, relations?: UserRelation): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        id,
      },
      relations,
    });
    if (!user) {
      throw new NotFoundException(errorMessages.user.notFound);
    }
    return user;
  }

  public async save(user: User) {
    return this.repository.save(user);
  }
}
```

## src/api/user/user.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../../database/entities/user.entity';
import { UserController } from './controllers/user.controller';
import { UserService } from './services/user.service';

@Module({
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
  imports: [TypeOrmModule.forFeature([User])],
})
export class UserModule {}
```

## src/app.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
```

## src/app.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

## src/app.module.ts

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config'; // Asegúrate de importar ConfigService
import { TypeOrmModule } from '@nestjs/typeorm';
import { BullModule } from '@nestjs/bullmq';
import * as Joi from 'joi';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { TypeOrmConfigService } from './database/typeorm/typeorm.service';
import { ApiModule } from './api/api.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      validationSchema: Joi.object({
        NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),
        PORT: Joi.number().default(3000),
        DATABASE_HOST: Joi.string().required(),
        DATABASE_PORT: Joi.number().default(5432),
        DATABASE_USER: Joi.string().required(),
        DATABASE_PASSWORD: Joi.string().required(),
        DATABASE_NAME: Joi.string().required(),
        JWT_SECRET: Joi.string().required(),
        REDIS_HOST: Joi.string().default('127.0.0.1'),
        REDIS_PORT: Joi.number().default(6379),
      }),
    }),
    
    // Configuración BLINDADA de BullMQ
    BullModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const host = configService.get<string>('REDIS_HOST');
        const port = configService.get<number>('REDIS_PORT');
        
        console.log(`[BullMQ] Intentando conectar a Redis en: ${host}:${port}`);
        
        return {
          connection: {
            host: host,
            port: Number(port), // Forzamos que sea numero sí o sí
          },
        };
      },
      inject: [ConfigService],
    }),

    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    ApiModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

## src/app.service.ts

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
```

## src/common/helper/findOneParams.dto.ts

```typescript
import { IsNumberString } from 'class-validator';

export class FindOneParams {
  @IsNumberString()
  id: number;
}
```

## src/common/helper/serialize.interceptor.ts

```typescript
import {
  UseInterceptors,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { plainToInstance } from 'class-transformer';

interface ClassConstructor {
  new (...args: any[]): any;
}

export function Serialize(dto: ClassConstructor) {
  return UseInterceptors(new SerializeInterceptor(dto));
}

export class SerializeInterceptor implements NestInterceptor {
  constructor(private dto: any) {}

  intercept(context: ExecutionContext, handler: CallHandler): Observable<any> {
    return handler.handle().pipe(
      map((data: any) => {
        return plainToInstance(this.dto, data, {
          excludeExtraneousValues: true,
        });
      }),
    );
  }
}
```

## src/common/helper/success-response.interceptor.ts

```typescript
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { map, Observable } from 'rxjs';

@Injectable()
export class SucessResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        return {
          isSuccess: true,
          message: 'success',
          data,
          errorCode: null,
          errors: [],
        };
      }),
    );
  }
}

export const successObject = {
  message: 'success',
};
```

## src/database/entities/category.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  PrimaryColumn,
} from 'typeorm';
import { Product } from './product.entity';

@Entity()
export class Category {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar' })
  public name: string;

  @OneToMany(() => Product, (product) => product.category)
  products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CategoryIds {
  Computers = 1,
  Fashion,
}

export enum Categories {
  Computers = 'Computers',
  Fashion = 'Fashion',
}
```

## src/database/entities/color.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Color {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public name!: string;

  @Column({ type: 'varchar', length: 10 })
  public hexCode: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum Colors {
  NA = 'NA',
  Red = 'red',
  Green = 'green',
  Blue = 'blue',
}

export enum ColorsHexCodes {
  NA = 'NA',
  Red = '#FF0000',
  Green = '#00FF00',
  Blue = '#0000FF',
}
```

## src/database/entities/country.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Country {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CountryCodes {
  Egypt = 'EG',
}

export enum Countries {
  Egypt = 'Egypt',
}
```

## src/database/entities/currency.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Currency {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CurrencyCodes {
  EGP = 'EGP',
}

export enum CurrencyNames {
  EGP = 'Egyptian Pound',
}
```

## src/database/entities/inventory.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class Inventory {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @Column({ type: 'int' })
  public quantity: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/product.entity.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import {
  ProductDetails,
  ProductDetailsTypeFn,
} from 'src/api/product/dto/productDetails';
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  JoinColumn,
  Index,
} from 'typeorm';
import { Category } from './category.entity';
import { User } from './user.entity';

@Entity()
export class Product {
  @PrimaryGeneratedColumn()
  @IsDefined()
  @IsNumber()
  public id!: number;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  @Index()
  public code: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public title: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public variationType: string;

  @Column({ type: 'text', nullable: true })
  @IsDefined()
  @IsString()
  public description?: string | null;

  @Column({ type: 'text', array: true, default: [] })
  @ArrayMinSize(1)
  @IsString({ each: true })
  public about?: string[];

  @Column({ type: 'jsonb', nullable: true })
  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: Partial<ProductDetails> | null;

  @Column({ default: false })
  public isActive: boolean;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public merchantId: number;

  @ManyToOne(() => User, (user) => user.products)
  @JoinColumn({ name: 'merchantId' })
  public merchant: User;

  @ManyToOne(() => Category, (category) => category.products)
  @JoinColumn({ name: 'categoryId' })
  public category: Category;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public categoryId: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum VariationTypes {
  NONE = 'NONE',
  OnlySize = 'OnlySize',
  OnlyColor = 'OnlyColor',
  SizeAndColor = 'SizeAndColor',
}
export const variationTypesKeys = Object.keys(VariationTypes);
```

## src/database/entities/productVariation.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Color } from './color.entity';
import { Product } from './product.entity';
import { Size } from './size.entity';

@Entity()
export class ProductVariation {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => Product)
  @JoinColumn({ name: 'productId' })
  public product: Product;

  @Column({ type: 'int' })
  public productId: number;

  @ManyToOne(() => Size)
  @JoinColumn({ name: 'sizeCode' })
  public size: Size;

  @Column({ type: 'varchar', length: 7 })
  public sizeCode: string;

  @ManyToOne(() => Color)
  @JoinColumn({ name: 'colorName' })
  public color: Color;

  @Column({ type: 'varchar', length: 30 })
  public colorName: string;

  @Column({ type: 'text', array: true, default: [] })
  public imageUrls: string[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/productVariation_price.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { Currency } from './currency.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class ProductVariationPrice {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @ManyToOne(() => Currency)
  @JoinColumn({ name: 'currencyCode' })
  public currency: Currency;

  @Column({ type: 'varchar', length: 7 })
  public currencyCode: string;

  @Column({ type: 'float' })
  public price: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/role.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
  ManyToMany,
} from 'typeorm';
import { User } from './user.entity';

@Entity()
export class Role {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public name: string;

  @ManyToMany(() => User, (user) => user.roles)
  public users: User[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/size.entity.ts

```typescript
import {
  Entity,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Size {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public code!: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum SizeCodes {
  NA = 'NA',
  Small = 'S',
  Medium = 'M',
  Large = 'L',
  XLarge = 'XL',
  XXLarge = 'XXL',
}
```

## src/database/entities/user.entity.ts

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToMany,
  JoinTable,
  OneToMany,
} from 'typeorm';
import { Product } from './product.entity';
import { Role } from './role.entity';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public email: string;

  @Column({ type: 'varchar' })
  public password: string;

  @ManyToMany(() => Role, (role) => role.users)
  @JoinTable({ name: 'user_roles' })
  public roles: Role[];

  @OneToMany(() => Product, (product) => product.merchant)
  public products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/migration/datasource.ts

```typescript
import { DataSource } from 'typeorm';
import { dataSourceOptions } from '../typeorm/typeOrm.config';

const datasource = new DataSource(dataSourceOptions);

export default datasource;
```

## src/database/seed/seed.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Category } from 'src/database/entities/category.entity';
import { Role } from 'src/database/entities/role.entity';
import { User } from 'src/database/entities/user.entity';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { Color } from '../entities/color.entity';
import { Country } from '../entities/country.entity';
import { Currency } from '../entities/currency.entity';
import { Size } from '../entities/size.entity';
import { SeedService } from './seed.service';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';
//  La importación 'configuration' ha sido eliminada

@Module({
  imports: [
    // Agregamos ConfigModule para que lea el .env al ejecutar seeds
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    TypeOrmModule.forFeature([
      Role,
      User,
      Category,
      Size,
      Color,
      Country,
      Currency,
    ]),
  ],
  controllers: [],
  providers: [
    SeedService,
    RolesSeeder,
    AdminSeeder,
    CategorySeeder,
    SizeSeeder,
    ColorSeeder,
    CountrySeeder,
    CurrencySeeder,
  ],
})
export class SeedModule {}
```

## src/database/seed/seed.service.ts

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Promise as Bluebird } from 'bluebird';
import { SeederInterface } from './seeder.interface';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';

@Injectable()
export class SeedService {
  private readonly seeders: SeederInterface[] = [];
  private readonly logger = new Logger(SeedService.name);

  constructor(
    rolesSeeder: RolesSeeder,
    adminSeeder: AdminSeeder,
    categoriesSeeder: CategorySeeder,
    sizesSeeder: SizeSeeder,
    colorsSeeder: ColorSeeder,
    countrySeeder: CountrySeeder,
    currencySeeder: CurrencySeeder,
  ) {
    this.seeders = [
      rolesSeeder,
      adminSeeder,
      categoriesSeeder,
      sizesSeeder,
      colorsSeeder,
      countrySeeder,
      currencySeeder,
    ];
  }

  async seed() {
    await Bluebird.each(this.seeders, async (seeder: SeederInterface) => {
      this.logger.log(`Seeding ${seeder.constructor.name}`);
      await seeder.seed();
    });
  }
}
```

## src/database/seed/seed.ts

```typescript
import { NestFactory } from '@nestjs/core';
import { SeedModule } from './seed.module';
import { SeedService } from './seed.service';

async function bootstrap() {
  const app = await NestFactory.create(SeedModule);
  const seedService = app.get(SeedService);
  await seedService.seed();
  await app.close();
}
bootstrap();
```

## src/database/seed/seeder.interface.ts

```typescript
export interface SeederInterface {
  seed(): Promise<void>;
}
```

## src/database/seed/seeders/category.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Categories,
  Category,
  CategoryIds,
} from 'src/database/entities/category.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CategorySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Category)
    private readonly categoriesRepository: Repository<Category>,
  ) {}

  async seed() {
    const data: Partial<Category>[] = this.generateData();
    await this.categoriesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Category>[] {
    const data: Partial<Category>[] = [];
    Object.keys(Categories).forEach((key) => {
      data.push({
        id: CategoryIds[key],
        name: Categories[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/color.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Color,
  Colors,
  ColorsHexCodes,
} from 'src/database/entities/color.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class ColorSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Color)
    private readonly colorsRepository: Repository<Color>,
  ) {}

  async seed() {
    const data: Partial<Color>[] = this.generateData();
    await this.colorsRepository.upsert(data, {
      conflictPaths: ['name'],
    });
  }

  generateData(): Partial<Color>[] {
    const data: Partial<Color>[] = [];
    Object.keys(Colors).forEach((key) => {
      data.push({
        name: Colors[key],
        hexCode: ColorsHexCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/country.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Countries,
  Country,
  CountryCodes,
} from 'src/database/entities/country.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CountrySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Country)
    private readonly countryRepository: Repository<Country>,
  ) {}

  async seed() {
    const data: Partial<Country>[] = this.generateData();
    await this.countryRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Country>[] {
    const data: Partial<Country>[] = [];
    Object.keys(Countries).forEach((key) => {
      data.push({
        code: CountryCodes[key],
        name: Countries[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/currency.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Currency,
  CurrencyCodes,
  CurrencyNames,
} from 'src/database/entities/currency.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CurrencySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Currency)
    private readonly currencyRepository: Repository<Currency>,
  ) {}

  async seed() {
    const data: Partial<Currency>[] = this.generateData();
    await this.currencyRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Currency>[] {
    const data: Partial<Currency>[] = [];
    Object.keys(CurrencyCodes).forEach((key) => {
      data.push({
        code: CurrencyCodes[key],
        name: CurrencyNames[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/role.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';
import { Role } from 'src/database/entities/role.entity';
import { RoleIds, Roles } from 'src/api/role/enum/role.enum';

@Injectable()
export class RolesSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Role)
    private readonly rolesRepository: Repository<Role>,
  ) {}

  async seed() {
    const data: Partial<Role>[] = this.generateData();
    await this.rolesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Role>[] {
    const data: Partial<Role>[] = [];
    Object.keys(Roles).forEach((key) => {
      data.push({
        id: RoleIds[key],
        name: Roles[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/size.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Size, SizeCodes } from 'src/database/entities/size.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class SizeSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Size)
    private readonly SizeRepository: Repository<Size>,
  ) {}

  async seed() {
    const data: Partial<Size>[] = this.generateData();
    await this.SizeRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Size>[] {
    const data: Partial<Size>[] = [];
    Object.keys(SizeCodes).forEach((key) => {
      data.push({
        code: SizeCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/typeorm/typeOrm.config.ts

```typescript
/* eslint-disable prettier/prettier */
import { DataSource, DataSourceOptions } from 'typeorm';
import { config } from 'dotenv';

// Carga .env solo si estamos en local y no en producción (donde ya existen las vars)
if (process.env.NODE_ENV !== 'production') {
  config(); 
}

export const dataSourceOptions: DataSourceOptions = {
  type: 'postgres',
  host: process.env.DATABASE_HOST,
  port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
  database: process.env.DATABASE_NAME,
  username: process.env.DATABASE_USER,
  password: process.env.DATABASE_PASSWORD,
  entities: ['dist/**/*.entity.js'], // Apuntamos a dist para producción
  migrations: ['dist/database/migration/history/*.js'],
  synchronize: false, 
  logging: process.env.NODE_ENV === 'development',
};

// Default export para CLI de TypeORM
const datasource = new DataSource(dataSourceOptions);
export default datasource;
```

## src/database/typeorm/typeorm.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import { TypeOrmOptionsFactory, TypeOrmModuleOptions } from '@nestjs/typeorm';
import { dataSourceOptions } from 'src/database/typeorm/typeOrm.config';

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  public createTypeOrmOptions(): TypeOrmModuleOptions {
    return dataSourceOptions;
  }
}
```

## src/errors/custom/index.ts

```typescript
export interface ErrorBody extends Error {
  code: string;
}
//corrijo errores de texto wronCredentials por wrongCredentials
//invlidToken por invalidToken
export const errorMessages = {
  auth: {
    wrongCredentials: {
      message: 'wrong data provided',
      code: '60001',
    },
    userAlreadyExist: {
      message: 'user already exist',
      code: '60002',
    },
    expiredToken: {
      message: 'token expired',
      code: '60003',
    },
    invalidToken: {
      message: 'invalid token',
      code: '60004',
    },
    notAllowed: {
      message: 'not allowed',
      code: '60005',
    },
  },
  user: {
    notFound: {
      message: 'user not found',
      code: '60101',
    },
  },
  role: {
    notFound: {
      message: 'role not found',
      code: '60201',
    },
  },
  category: {
    notFound: {
      message: 'category not found',
      code: '60301',
    },
  },
  product: {
    notFound: {
      message: 'product not found',
      code: '60401',
    },
    notFulfilled: {
      message: 'not all product info is fulfilled',
      code: '60402',
    },
  },
  global: {
    internalError: {
      message: 'something went wrong',
      code: '70000',
    },
  },
};
```

## src/errors/errors.filter.ts

```typescript
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';
import { ErrorBody, errorMessages } from './custom';

@Catch()
export class ErrorsFilter implements ExceptionFilter {
  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

  catch(exception: Error, host: ArgumentsHost): void {
    Logger.error(exception.message);
    const { httpAdapter } = this.httpAdapterHost;

    const ctx = host.switchToHttp();
    if (exception instanceof HttpException) {
      const message = exception.message;
      const httpStatus =
        exception.getStatus() || HttpStatus.INTERNAL_SERVER_ERROR;
      const errorMessage = (exception.getResponse() as HttpException).message;
      const errorCode = (exception.getResponse() as ErrorBody).code || '60400';
      const errors = Array.isArray(errorMessage)
        ? errorMessage
        : [errorMessage];
      const responseBody = {
        isSuccess: false,
        message,
        errorCode,
        data: null,
        errors,
      };

      httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);
    } else {
      const responseBody = {
        isSuccess: false,
        message: errorMessages.global.internalError.message,
        errorCode: errorMessages.global.internalError.code,
        data: null,
        errors: [errorMessages.global.internalError.message],
      };

      httpAdapter.reply(
        ctx.getResponse(),
        responseBody,
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
```

## src/main.ts

```typescript
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe({ transform: true }));
  await app.listen(3000);
}
bootstrap();
```

## Statistics

- Total Files: 72
- Total Characters: 173922
- Total Tokens: 0
``````

## src/api/api.module.ts

```typescript
import { Module } from '@nestjs/common';
import { APP_FILTER, APP_INTERCEPTOR } from '@nestjs/core';
import { SucessResponseInterceptor } from 'src/common/helper/success-response.interceptor';
import { AuthModule } from './auth/auth.module';
import { UserModule } from './user/user.module';
import { RoleModule } from './role/role.module';
import { ProductModule } from './product/product.module';
import { ErrorsFilter } from 'src/errors/errors.filter';
import { InventoryModule } from './inventory/inventory.module';

@Module({
  imports: [AuthModule, UserModule, RoleModule, ProductModule, InventoryModule],
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: SucessResponseInterceptor,
    },
    {
      provide: APP_FILTER,
      useClass: ErrorsFilter,
    },
  ],
})
export class ApiModule {}
```

## src/api/auth/auth.module.ts

```typescript
import { Module } from '@nestjs/common';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { RoleModule } from '../role/role.module';
import { AuthController } from './controllers/auth.controller';
import { AuthService } from './services/auth.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [
    UserModule,
    TypeOrmModule.forFeature([User]),
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '3h' },
    }),
    RoleModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, UserService],
  exports: [],
})
export class AuthModule {}
```

## src/api/auth/controllers/auth.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from '../services/auth.service';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;
  let fakeAuthService: Partial<AuthService>;

  beforeEach(async () => {
    fakeAuthService = {
      register: () => {
        return Promise.resolve({
          message: 'success',
        });
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: fakeAuthService,
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/auth/controllers/auth.controller.ts

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { CreateUserDto } from 'src/api/user/dto/user.dto';
import { AuthService } from '../services/auth.service';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  login(@Body() user: CreateUserDto) {
    return this.authService.login(user);
  }

  @Post('register')
  register(@Body() user: CreateUserDto) {
    return this.authService.register(user);
  }
}
```

## src/api/auth/dto/auth.dto.ts

```typescript
import { IsNotEmpty } from 'class-validator';

export class PayloadDto {
  @IsNotEmpty()
  public email: string;

  @IsNotEmpty()
  public id: number;
}
```

## src/api/auth/guards/auth.decorator.ts

```typescript
import { applyDecorators, SetMetadata, UseGuards } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { RolesGuard } from './roles.guard';

export function Auth(...roleIds: number[]) {
  return applyDecorators(
    SetMetadata('roleIds', roleIds),
    UseGuards(AuthGuard, RolesGuard),
  );
}
```

## src/api/auth/guards/roles.guard.ts

```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private readonly userService: UserService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const roles = this.reflector.get<number[]>('roleIds', context.getHandler());
    if (roles.length === 0) return true;
    const request = context.switchToHttp().getRequest();
    if (!request.user.roles.some((userRole) => roles.includes(userRole.id)))
      throw new UnauthorizedException(errorMessages.auth.notAllowed);

    return true;
  }
}
```

## src/api/auth/guards/user.decorator.ts

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from 'src/database/entities/user.entity';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext): User => {
    const req = context.switchToHttp().getRequest();
    return req.user;
  },
);
```

## src/api/inventory/controllers/inventory.controller.ts

```typescript
/* eslint-disable prettier/prettier */
import { Controller, Get, Param, ParseIntPipe } from '@nestjs/common';
import { InventoryService } from '../services/inventory.service';
//import { Auth } from 'src/api/auth/guards/auth.decorator';
// Importamos Auth para proteger la ruta, aunque sea de lectura (opcional según regla de negocio)

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @Get('product/:id')
  async getProductStock(@Param('id', ParseIntPipe) productId: number) {
    return this.inventoryService.getStockByProduct(productId);
  }
}
```

## src/api/inventory/inventory.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';
import { InventoryController } from './controllers/inventory.controller';
import { InventoryService } from './services/inventory.service';
import { InventoryProcessor } from './inventory.processor'; // <--- Importamos

@Module({
  imports: [
    TypeOrmModule.forFeature([Inventory, ProductVariation]),
  ],
  controllers: [InventoryController],
  providers: [InventoryService, 
    InventoryProcessor // Registramos el processor como provider (importante )

  ],
  exports: [InventoryService], // Exportamos el servicio para usarlo en otros lados si hiciera falta
})
export class InventoryModule {}
```

## src/api/inventory/inventory.processor.ts

```typescript
/* eslint-disable prettier/prettier */
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { Logger } from '@nestjs/common';
import { InventoryService } from './services/inventory.service';

@Processor('catalog-queue')
export class InventoryProcessor extends WorkerHost {
  private readonly logger = new Logger(InventoryProcessor.name);

  constructor(private readonly inventoryService: InventoryService) {
    super();
  }

  async process(job: Job<any, any, string>): Promise<any> {
    this.logger.log(`⚡ Evento recibido: ${job.name} | JobId: ${job.id}`);

    switch (job.name) {
      case 'product.created':
        return this.handleProductCreated(job);
      case 'product.deleted':
        return this.handleProductDeleted(job);
      default:
        this.logger.warn(`Evento desconocido ignorado: ${job.name}`);
    }
  }

  // Manejo del Evento 1
  private async handleProductCreated(job: Job) {
    const { productId } = job.data;
    this.logger.log(`📦 Creando inventario inicial para Producto ID: ${productId}...`);
    
    try {
      // Aquí simulamos la creación. En un caso real, ProductService debería enviar 
      // el ID de la "Variación" (Talla/Color), no solo del Producto padre.
      // Como el challenge pide "base razonable", asumiremos que creamos stock 
      // para una variación placeholder o manejamos la lógica aquí.
      
      // Llamada al servicio de inventario (que implementaremos abajo)
      await this.inventoryService.createInitialStock(productId);
      
      this.logger.log(`✅ Inventario creado exitosamente para Producto ID: ${productId}`);
    } catch (error) {
      this.logger.error(`❌ Error creando inventario: ${error.message}`);
      // BullMQ reintentará esto automáticamente si fallamos aquí
      throw error; 
    }
  }

  // Manejo del Evento 2
  private async handleProductDeleted(job: Job) {
    const { productId } = job.data;
    this.logger.warn(`🗑️ Producto ${productId} eliminado. Limpiando stock asociado...`);
    
    // Aquí llamaríamos a un método de servicio para borrar/archivar
    // await this.inventoryService.removeStockForProduct(productId);
    
    // Simulamos un delay para ver la asincronía
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    this.logger.log(`✅ Stock del producto ${productId} eliminado correctamente.`);
  }
}
```

## src/api/inventory/services/inventory.service.ts

```typescript
/* eslint-disable prettier/prettier */
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';

@Injectable()
export class InventoryService {
  private readonly logger = new Logger(InventoryService.name);

  constructor(
    @InjectRepository(Inventory)
    private readonly inventoryRepo: Repository<Inventory>,
    @InjectRepository(ProductVariation)
    private readonly variationRepo: Repository<ProductVariation>,
  ) {}

  /**
   * Maneja el evento 'product.created'.
   * Intenta inicializar stock si existen variaciones, o simula la accion.
   */
  async createInitialStock(productId: number) {
    // 1. Buscamos si el producto ya tiene variaciones (ej. si se crearon en la misma transaccion)
    const variations = await this.variationRepo.find({
      where: { productId },
    });

    const countryCode = 'EG'; // Hardcodeado por reglas de negocio actuales

    // CASO A: El producto se creo pero aon no tiene Talla/Color definido.
    if (variations.length === 0) {
      this.logger.log(
        `[LOGIC] El producto ID ${productId} no tiene variaciones aún. No se puede crear registro en tabla 'Inventory' por restricción de FK.`,
      );
      this.logger.log(`[SIMULATION] Se reserva espacio lógico de inventario para Producto ${productId}.`);
      return;
    }

    // CASO B: (Edge Case) El producto ya tiene variaciones, creamos stock en 0 para cada una.
    const inventoryEntities = variations.map((variation) => {
      return this.inventoryRepo.create({
        productVariationId: variation.id,
        countryCode: countryCode,
        quantity: 0, // Stock inicial por defecto
      });
    });

    await this.inventoryRepo.save(inventoryEntities);
    this.logger.log(`✅ Stock inicial (0) creado para ${variations.length} variaciones del producto ${productId}.`);
  }

  /*
    Maneja el evento 'product.deleted'.
    Elimina todo registro de inventario asociado a las variaciones de ese producto.
   */
  async deleteStockForProduct(productId: number) {
    // Usamos QueryBuilder para hacer un DELETE con Subquery, es mas eficiente que buscar y borrar uno por uno.
    // SQL Equivalente: DELETE FROM inventory WHERE productVariationId IN (SELECT id FROM product_variation WHERE productId = X)
    
    const variations = await this.variationRepo.find({ where: { productId }, select: ['id'] });
    
    if (variations.length === 0) {
        this.logger.log(`No hay stock que limpiar para el producto ${productId}`);
        return;
    }

    const variationIds = variations.map(v => v.id);

    const result = await this.inventoryRepo
      .createQueryBuilder()
      .delete()
      .from(Inventory)
      .where('productVariationId IN (:...ids)', { ids: variationIds })
      .execute();

    this.logger.log(`🗑️ Eliminados ${result.affected} registros de inventario para el producto ${productId}.`);
  }

  // --- Metodos de Lectura (Frontend) ---

  async getStockByProduct(productId: number) {
    // Buscamos todas las variaciones de un producto
    const variations = await this.variationRepo.find({
      where: { productId },
      relations: ['product'], // Opcional, si necesitas datos del padre
    });

    if (!variations.length) {
      return { productId, totalStock: 0, breakdown: [], message: 'No variations found' };
    }

    const variationIds = variations.map((v) => v.id);

    // Buscamos el stock de esas variaciones
    const stockItems = await this.inventoryRepo
      .createQueryBuilder('inventory')
      .where('inventory.productVariationId IN (:...ids)', { ids: variationIds })
      .getMany();

    const totalStock = stockItems.reduce((acc, item) => acc + item.quantity, 0);

    return {
      productId,
      totalStock,
      breakdown: stockItems,
    };
  }
}
```

## src/api/product/controllers/product.controller.ts

```typescript
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { RoleIds } from '../../role/enum/role.enum';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { ProductService } from '../services/product.service';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { FindOneParams } from 'src/common/helper/findOneParams.dto';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { User } from 'src/database/entities/user.entity';

@Controller('product')
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Get(':id')
  async getProduct(@Param() product: FindOneParams) {
    return this.productService.getProduct(product.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post('create')
  async createProduct(
    @Body() body: CreateProductDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.createProduct(body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/details')
  async addProductDetails(
    @Param() product: FindOneParams,
    @Body() body: ProductDetailsDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.addProductDetails(product.id, body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/activate')
  async activateProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.activateProduct(product.id, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Delete(':id')
  async deleteProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.deleteProduct(product.id, user.id);
  }
}
```

## src/api/product/dto/product.dto.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsIn,
  IsNotEmpty,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import { variationTypesKeys } from 'src/database/entities/product.entity';
import { ProductDetails, ProductDetailsTypeFn } from './productDetails';

export class CreateProductDto {
  @IsNumber()
  @IsNotEmpty()
  public categoryId: number;
}

export class ProductDetailsDto {
  @IsString()
  @IsNotEmpty()
  public title: string;

  @IsString()
  @IsNotEmpty()
  public code: string;

  @IsDefined()
  @IsString()
  @IsIn(variationTypesKeys)
  public variationType: string;

  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: ProductDetails;

  @ArrayMinSize(1)
  @IsString({ each: true })
  public about: string[];

  @IsString()
  @IsNotEmpty()
  public description: string;
}
```

## src/api/product/dto/productDetails/computer.details.ts

```typescript
import { IsIn, IsNotEmpty, IsNumber, IsString } from 'class-validator';
import { Categories } from 'src/database/entities/category.entity';

export class ComputerDetails {
  @IsString()
  @IsNotEmpty()
  category = Categories.Computers;

  @IsNumber()
  capacity: number;

  @IsString()
  @IsIn(['GB', 'TB'])
  capacityUnit: 'GB' | 'TB';

  @IsString()
  @IsIn(['SSD', 'HD'])
  capacityType: 'SSD' | 'HD';

  @IsString()
  @IsNotEmpty()
  brand: string;

  @IsString()
  @IsNotEmpty()
  series: string;
}
```

## src/api/product/dto/productDetails/index.ts

```typescript
import { BadRequestException } from '@nestjs/common';
import { TypeHelpOptions } from 'class-transformer';
import { Categories } from 'src/database/entities/category.entity';
import { ComputerDetails } from './computer.details';
import { TestDetails } from './test.details';

export type ProductDetails = ComputerDetails | TestDetails;

export function ProductDetailsTypeFn(options: TypeHelpOptions) {
  switch (options.object?.details?.category) {
    case Categories.Computers:
      return ComputerDetails;
    case 'Test':
      return TestDetails;
  }

  throw new BadRequestException('invalid details.category input');
}
```

## src/api/product/dto/productDetails/test.details.ts

```typescript
export class TestDetails {
  category = 'Test';
  test: boolean;
}
```

## src/api/product/product.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ProductService } from './services/product.service';
import { ProductController } from './controllers/product.controller';
import { Category } from '../../database/entities/category.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { Product } from 'src/database/entities/product.entity';
import { BullModule } from '@nestjs/bullmq'; 
@Module({
  imports: [TypeOrmModule.forFeature([User, Product, Category]), UserModule,
 // Registramos la cola donde vamos a publicar mensajes
    BullModule.registerQueue({
      name: 'catalog-queue',
    }),],
  controllers: [ProductController],
  providers: [ProductService],
})
export class ProductModule {}
```

## src/api/product/services/product.service.ts

```typescript
/* eslint-disable prettier/prettier */
import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { DeleteResult, EntityManager } from 'typeorm';
import { InjectEntityManager } from '@nestjs/typeorm';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { Category } from '../../../database/entities/category.entity';
import { Product } from 'src/database/entities/product.entity';
import { errorMessages } from 'src/errors/custom';
import { validate } from 'class-validator';
import { successObject } from 'src/common/helper/success-response.interceptor';
import { InjectQueue } from '@nestjs/bullmq'; // <--- Importamos
import { Queue } from 'bullmq'; // <--- Importamos 

@Injectable()
export class ProductService {
  constructor(
    @InjectEntityManager()
    private readonly entityManager: EntityManager,
    // Inyectamos la cola definida en el modulo
    @InjectQueue('catalog-queue') private readonly catalogQueue: Queue,
  ) {}

  async getProduct(productId: number) {
    const product = await this.entityManager.findOne(Product, {
      where: {
        id: productId,
      },
    });

    if (!product) throw new NotFoundException(errorMessages.product.notFound);

    return product;
  }

 async createProduct(data: CreateProductDto, merchantId: number) {
    const category = await this.entityManager.findOne(Category, {
      where: { id: data.categoryId },
    });
    if (!category) throw new NotFoundException(errorMessages.category.notFound);

    const product = await this.entityManager.create(Product, {
      category,
      merchantId,
    });

    const savedProduct = await this.entityManager.save(product);

    // --- EVENTO 1: PRODUCTO CREADO ---
    // Publicamos el evento a Redis. Esto es asíncrono y desacoplado.
    await this.catalogQueue.add('product.created', {
      productId: savedProduct.id,
      merchantId: merchantId,
      sku: savedProduct.code // Si tuvieras SKU
    });
    // ---------------------------------

    return savedProduct;
  }
  async addProductDetails(
    productId: number,
    body: ProductDetailsDto,
    merchantId: number,
  ) {
    const result = await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({
        ...body,
      })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute();
    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);
    return await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({ ...body })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute().then(res => res.raw[0]);
  }
  async activateProduct(productId: number, merchantId: number) {
    if (!(await this.validate(productId)))
      throw new ConflictException(errorMessages.product.notFulfilled);

    return await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({ isActive: true })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id', 'isActive'])
      .execute().then(res => res.raw[0]);
  }

  async validate(productId: number) {
     const product = await this.entityManager.findOne(Product, { where: { id: productId } });
    if (!product) throw new NotFoundException(errorMessages.product.notFound);
    const errors = await validate(product);
    return errors.length === 0;
  }

  async deleteProduct(productId: number, merchantId: number) {
    const result = await this.entityManager
      .createQueryBuilder()
      .delete()
      .from(Product)
      .where('id = :productId', { productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .execute();

    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);

    // Si se borró con éxito, avisamos al inventario para que limpie
    await this.catalogQueue.add('product.deleted', {
      productId: productId,
    });
    // ------------------------------------

    return successObject;
  }
}
```

## src/api/role/controllers/role.controller.spec.ts

```typescript
import { ConfigModule } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { configuration } from 'src/config';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { AuthModule } from '../../auth/auth.module';
import { RoleController } from './role.controller';
import { Role } from '../../../database/entities/role.entity';
import { RoleIds, Roles } from '../enum/role.enum';
import { RoleService } from '../services/role.service';
import { UserService } from 'src/api/user/services/user.service';

describe('RoleController', () => {
  let controller: RoleController;
  let fakeRoleService: Partial<RoleService>;
  let fakeUserService: Partial<UserService>;

  const customerRole = {
    id: RoleIds.Customer,
    name: Roles.Customer,
  } as Role;

  beforeEach(async () => {
    fakeRoleService = {
      findById: () => {
        return Promise.resolve(customerRole);
      },
    };
    fakeUserService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [RoleController],
      providers: [
        {
          provide: RoleService,
          useValue: fakeRoleService,
        },
        {
          provide: UserService,
          useValue: fakeUserService,
        },
      ],
      imports: [
        AuthModule,
        ConfigModule.forRoot({ load: [configuration], isGlobal: true }),
        TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
      ],
    }).compile();

    controller = module.get<RoleController>(RoleController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/role/controllers/role.controller.ts

```typescript
import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { AssignRoleDto } from '../dto/role.dto';
import { RoleIds } from '../enum/role.enum';
import { RoleService } from '../services/role.service';

@Controller('role')
export class RoleController {
  constructor(private readonly roleService: RoleService) {}

  @Auth(RoleIds.Admin)
  @Post('assign')
  async assignRoleToUser(@Body() body: AssignRoleDto) {
    return this.roleService.assignRoleToUser(body);
  }
}
```

## src/api/role/dto/role.dto.ts

```typescript
import { IsNotEmpty, IsNumber } from 'class-validator';

export class AssignRoleDto {
  @IsNumber()
  @IsNotEmpty()
  public userId: number;

  @IsNumber()
  @IsNotEmpty()
  public roleId: number;
}
```

## src/api/role/enum/role.enum.ts

```typescript
export enum RoleIds {
  Customer = 1,
  Merchant,
  Admin,
}

export enum Roles {
  Customer = 'Customer',
  Merchant = 'Merchant',
  Admin = 'Admin',
}
```

## src/api/role/role.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Role } from '../../database/entities/role.entity';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { RoleController } from './controllers/role.controller';
import { RoleService } from './services/role.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [TypeOrmModule.forFeature([Role, User]), UserModule],
  controllers: [RoleController],
  providers: [RoleService, UserService],
  exports: [RoleService],
})
export class RoleModule {}
```

## src/api/role/services/role.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Role } from 'src/database/entities/role.entity';
import { AssignRoleDto } from '../dto/role.dto';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RoleService {
  constructor(
    @InjectRepository(Role) private readonly rolesRepository: Repository<Role>,
    private readonly userService: UserService,
  ) {}

  async assignRoleToUser(data: AssignRoleDto) {
    const role = await this.findById(data.roleId);
    const user = await this.userService.findById(data.userId, { roles: true });
    if (!user.roles.some((userRole) => userRole.id === data.roleId)) {
      user.roles.push(role);
    }
    return this.userService.save(user);
  }

  async findById(roleId: number) {
    const role = await this.rolesRepository.findOne({
      where: {
        id: roleId,
      },
    });
    if (!role) {
      throw new NotFoundException(errorMessages.role.notFound);
    }
    return role;
  }
}
```

## src/api/user/controllers/user.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { Serialize } from 'src/common/helper/serialize.interceptor';
import { User } from 'src/database/entities/user.entity';
import { UserDto } from '../dto/user.dto';
import { UserService } from '../services/user.service';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Auth()
  @Serialize(UserDto)
  @Get('profile')
  profile(@CurrentUser() user: User) {
    return this.userService.findById(user.id);
  }
}
```

## src/api/user/dto/user.dto.ts

```typescript
import { Expose } from 'class-transformer';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  public email: string;

  @IsString()
  @IsNotEmpty()
  public password: string;
}

export class UserDto {
  @Expose()
  public id: number;

  @Expose()
  public email: string;
}
```

## src/api/user/dto/user.types.ts

```typescript
export type UserRelation = {
  roles: boolean;
};
```

## src/api/user/services/user.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { Repository } from 'typeorm';
import { hash, compare } from 'bcrypt';
import { InjectRepository } from '@nestjs/typeorm';
import { User } from 'src/database/entities/user.entity';
import { CreateUserDto } from '../dto/user.dto';
import { Role } from 'src/database/entities/role.entity';
import { UserRelation } from '../dto/user.types';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User) private readonly repository: Repository<User>,
  ) {}

  public async createUser(
    body: CreateUserDto,
    ...roles: Role[]
  ): Promise<User> {
    body.password = await hash(body.password, 10);
    const user: User = this.repository.create({
      ...body,
      roles,
    });

    return this.repository.save(user);
  }

  public async findByEmail(
    email: string,
    relations?: UserRelation,
  ): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        email,
      },
      relations,
    });
    return user;
  }

  public async comparePassword(password, userPassword): Promise<boolean> {
    return compare(password, userPassword);
  }

  public async findById(id: number, relations?: UserRelation): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        id,
      },
      relations,
    });
    if (!user) {
      throw new NotFoundException(errorMessages.user.notFound);
    }
    return user;
  }

  public async save(user: User) {
    return this.repository.save(user);
  }
}
```

## src/api/user/user.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../../database/entities/user.entity';
import { UserController } from './controllers/user.controller';
import { UserService } from './services/user.service';

@Module({
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
  imports: [TypeOrmModule.forFeature([User])],
})
export class UserModule {}
```

## src/app.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
```

## src/app.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

## src/app.module.ts

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config'; // Asegúrate de importar ConfigService
import { TypeOrmModule } from '@nestjs/typeorm';
import { BullModule } from '@nestjs/bullmq';
import * as Joi from 'joi';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { TypeOrmConfigService } from './database/typeorm/typeorm.service';
import { ApiModule } from './api/api.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      validationSchema: Joi.object({
        NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),
        PORT: Joi.number().default(3000),
        DATABASE_HOST: Joi.string().required(),
        DATABASE_PORT: Joi.number().default(5432),
        DATABASE_USER: Joi.string().required(),
        DATABASE_PASSWORD: Joi.string().required(),
        DATABASE_NAME: Joi.string().required(),
        JWT_SECRET: Joi.string().required(),
        REDIS_HOST: Joi.string().default('127.0.0.1'),
        REDIS_PORT: Joi.number().default(6379),
      }),
    }),
    
    // Configuración BLINDADA de BullMQ
    BullModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const host = configService.get<string>('REDIS_HOST');
        const port = configService.get<number>('REDIS_PORT');
        
        console.log(`[BullMQ] Intentando conectar a Redis en: ${host}:${port}`);
        
        return {
          connection: {
            host: host,
            port: Number(port), // Forzamos que sea numero sí o sí
          },
        };
      },
      inject: [ConfigService],
    }),

    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    ApiModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

## src/app.service.ts

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
```

## src/common/helper/findOneParams.dto.ts

```typescript
import { IsNumberString } from 'class-validator';

export class FindOneParams {
  @IsNumberString()
  id: number;
}
```

## src/common/helper/serialize.interceptor.ts

```typescript
import {
  UseInterceptors,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { plainToInstance } from 'class-transformer';

interface ClassConstructor {
  new (...args: any[]): any;
}

export function Serialize(dto: ClassConstructor) {
  return UseInterceptors(new SerializeInterceptor(dto));
}

export class SerializeInterceptor implements NestInterceptor {
  constructor(private dto: any) {}

  intercept(context: ExecutionContext, handler: CallHandler): Observable<any> {
    return handler.handle().pipe(
      map((data: any) => {
        return plainToInstance(this.dto, data, {
          excludeExtraneousValues: true,
        });
      }),
    );
  }
}
```

## src/common/helper/success-response.interceptor.ts

```typescript
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { map, Observable } from 'rxjs';

@Injectable()
export class SucessResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        return {
          isSuccess: true,
          message: 'success',
          data,
          errorCode: null,
          errors: [],
        };
      }),
    );
  }
}

export const successObject = {
  message: 'success',
};
```

## src/database/entities/category.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  PrimaryColumn,
} from 'typeorm';
import { Product } from './product.entity';

@Entity()
export class Category {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar' })
  public name: string;

  @OneToMany(() => Product, (product) => product.category)
  products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CategoryIds {
  Computers = 1,
  Fashion,
}

export enum Categories {
  Computers = 'Computers',
  Fashion = 'Fashion',
}
```

## src/database/entities/color.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Color {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public name!: string;

  @Column({ type: 'varchar', length: 10 })
  public hexCode: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum Colors {
  NA = 'NA',
  Red = 'red',
  Green = 'green',
  Blue = 'blue',
}

export enum ColorsHexCodes {
  NA = 'NA',
  Red = '#FF0000',
  Green = '#00FF00',
  Blue = '#0000FF',
}
```

## src/database/entities/country.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Country {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CountryCodes {
  Egypt = 'EG',
}

export enum Countries {
  Egypt = 'Egypt',
}
```

## src/database/entities/currency.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Currency {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CurrencyCodes {
  EGP = 'EGP',
}

export enum CurrencyNames {
  EGP = 'Egyptian Pound',
}
```

## src/database/entities/inventory.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class Inventory {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @Column({ type: 'int' })
  public quantity: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/product.entity.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import {
  ProductDetails,
  ProductDetailsTypeFn,
} from 'src/api/product/dto/productDetails';
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  JoinColumn,
  Index,
} from 'typeorm';
import { Category } from './category.entity';
import { User } from './user.entity';

@Entity()
export class Product {
  @PrimaryGeneratedColumn()
  @IsDefined()
  @IsNumber()
  public id!: number;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  @Index()
  public code: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public title: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public variationType: string;

  @Column({ type: 'text', nullable: true })
  @IsDefined()
  @IsString()
  public description?: string | null;

  @Column({ type: 'text', array: true, default: [] })
  @ArrayMinSize(1)
  @IsString({ each: true })
  public about?: string[];

  @Column({ type: 'jsonb', nullable: true })
  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: Partial<ProductDetails> | null;

  @Column({ default: false })
  public isActive: boolean;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public merchantId: number;

  @ManyToOne(() => User, (user) => user.products)
  @JoinColumn({ name: 'merchantId' })
  public merchant: User;

  @ManyToOne(() => Category, (category) => category.products)
  @JoinColumn({ name: 'categoryId' })
  public category: Category;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public categoryId: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum VariationTypes {
  NONE = 'NONE',
  OnlySize = 'OnlySize',
  OnlyColor = 'OnlyColor',
  SizeAndColor = 'SizeAndColor',
}
export const variationTypesKeys = Object.keys(VariationTypes);
```

## src/database/entities/productVariation.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Color } from './color.entity';
import { Product } from './product.entity';
import { Size } from './size.entity';

@Entity()
export class ProductVariation {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => Product)
  @JoinColumn({ name: 'productId' })
  public product: Product;

  @Column({ type: 'int' })
  public productId: number;

  @ManyToOne(() => Size)
  @JoinColumn({ name: 'sizeCode' })
  public size: Size;

  @Column({ type: 'varchar', length: 7 })
  public sizeCode: string;

  @ManyToOne(() => Color)
  @JoinColumn({ name: 'colorName' })
  public color: Color;

  @Column({ type: 'varchar', length: 30 })
  public colorName: string;

  @Column({ type: 'text', array: true, default: [] })
  public imageUrls: string[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/productVariation_price.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { Currency } from './currency.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class ProductVariationPrice {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @ManyToOne(() => Currency)
  @JoinColumn({ name: 'currencyCode' })
  public currency: Currency;

  @Column({ type: 'varchar', length: 7 })
  public currencyCode: string;

  @Column({ type: 'float' })
  public price: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/role.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
  ManyToMany,
} from 'typeorm';
import { User } from './user.entity';

@Entity()
export class Role {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public name: string;

  @ManyToMany(() => User, (user) => user.roles)
  public users: User[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/size.entity.ts

```typescript
import {
  Entity,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Size {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public code!: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum SizeCodes {
  NA = 'NA',
  Small = 'S',
  Medium = 'M',
  Large = 'L',
  XLarge = 'XL',
  XXLarge = 'XXL',
}
```

## src/database/entities/user.entity.ts

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToMany,
  JoinTable,
  OneToMany,
} from 'typeorm';
import { Product } from './product.entity';
import { Role } from './role.entity';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public email: string;

  @Column({ type: 'varchar' })
  public password: string;

  @ManyToMany(() => Role, (role) => role.users)
  @JoinTable({ name: 'user_roles' })
  public roles: Role[];

  @OneToMany(() => Product, (product) => product.merchant)
  public products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/migration/datasource.ts

```typescript
import { DataSource } from 'typeorm';
import { dataSourceOptions } from '../typeorm/typeOrm.config';

const datasource = new DataSource(dataSourceOptions);

export default datasource;
```

## src/database/seed/seed.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Category } from 'src/database/entities/category.entity';
import { Role } from 'src/database/entities/role.entity';
import { User } from 'src/database/entities/user.entity';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { Color } from '../entities/color.entity';
import { Country } from '../entities/country.entity';
import { Currency } from '../entities/currency.entity';
import { Size } from '../entities/size.entity';
import { SeedService } from './seed.service';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';
//  La importación 'configuration' ha sido eliminada

@Module({
  imports: [
    // Agregamos ConfigModule para que lea el .env al ejecutar seeds
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    TypeOrmModule.forFeature([
      Role,
      User,
      Category,
      Size,
      Color,
      Country,
      Currency,
    ]),
  ],
  controllers: [],
  providers: [
    SeedService,
    RolesSeeder,
    AdminSeeder,
    CategorySeeder,
    SizeSeeder,
    ColorSeeder,
    CountrySeeder,
    CurrencySeeder,
  ],
})
export class SeedModule {}
```

## src/database/seed/seed.service.ts

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Promise as Bluebird } from 'bluebird';
import { SeederInterface } from './seeder.interface';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';

@Injectable()
export class SeedService {
  private readonly seeders: SeederInterface[] = [];
  private readonly logger = new Logger(SeedService.name);

  constructor(
    rolesSeeder: RolesSeeder,
    adminSeeder: AdminSeeder,
    categoriesSeeder: CategorySeeder,
    sizesSeeder: SizeSeeder,
    colorsSeeder: ColorSeeder,
    countrySeeder: CountrySeeder,
    currencySeeder: CurrencySeeder,
  ) {
    this.seeders = [
      rolesSeeder,
      adminSeeder,
      categoriesSeeder,
      sizesSeeder,
      colorsSeeder,
      countrySeeder,
      currencySeeder,
    ];
  }

  async seed() {
    await Bluebird.each(this.seeders, async (seeder: SeederInterface) => {
      this.logger.log(`Seeding ${seeder.constructor.name}`);
      await seeder.seed();
    });
  }
}
```

## src/database/seed/seed.ts

```typescript
import { NestFactory } from '@nestjs/core';
import { SeedModule } from './seed.module';
import { SeedService } from './seed.service';

async function bootstrap() {
  const app = await NestFactory.create(SeedModule);
  const seedService = app.get(SeedService);
  await seedService.seed();
  await app.close();
}
bootstrap();
```

## src/database/seed/seeder.interface.ts

```typescript
export interface SeederInterface {
  seed(): Promise<void>;
}
```

## src/database/seed/seeders/category.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Categories,
  Category,
  CategoryIds,
} from 'src/database/entities/category.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CategorySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Category)
    private readonly categoriesRepository: Repository<Category>,
  ) {}

  async seed() {
    const data: Partial<Category>[] = this.generateData();
    await this.categoriesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Category>[] {
    const data: Partial<Category>[] = [];
    Object.keys(Categories).forEach((key) => {
      data.push({
        id: CategoryIds[key],
        name: Categories[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/color.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Color,
  Colors,
  ColorsHexCodes,
} from 'src/database/entities/color.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class ColorSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Color)
    private readonly colorsRepository: Repository<Color>,
  ) {}

  async seed() {
    const data: Partial<Color>[] = this.generateData();
    await this.colorsRepository.upsert(data, {
      conflictPaths: ['name'],
    });
  }

  generateData(): Partial<Color>[] {
    const data: Partial<Color>[] = [];
    Object.keys(Colors).forEach((key) => {
      data.push({
        name: Colors[key],
        hexCode: ColorsHexCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/country.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Countries,
  Country,
  CountryCodes,
} from 'src/database/entities/country.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CountrySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Country)
    private readonly countryRepository: Repository<Country>,
  ) {}

  async seed() {
    const data: Partial<Country>[] = this.generateData();
    await this.countryRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Country>[] {
    const data: Partial<Country>[] = [];
    Object.keys(Countries).forEach((key) => {
      data.push({
        code: CountryCodes[key],
        name: Countries[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/currency.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Currency,
  CurrencyCodes,
  CurrencyNames,
} from 'src/database/entities/currency.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CurrencySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Currency)
    private readonly currencyRepository: Repository<Currency>,
  ) {}

  async seed() {
    const data: Partial<Currency>[] = this.generateData();
    await this.currencyRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Currency>[] {
    const data: Partial<Currency>[] = [];
    Object.keys(CurrencyCodes).forEach((key) => {
      data.push({
        code: CurrencyCodes[key],
        name: CurrencyNames[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/role.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';
import { Role } from 'src/database/entities/role.entity';
import { RoleIds, Roles } from 'src/api/role/enum/role.enum';

@Injectable()
export class RolesSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Role)
    private readonly rolesRepository: Repository<Role>,
  ) {}

  async seed() {
    const data: Partial<Role>[] = this.generateData();
    await this.rolesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Role>[] {
    const data: Partial<Role>[] = [];
    Object.keys(Roles).forEach((key) => {
      data.push({
        id: RoleIds[key],
        name: Roles[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/size.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Size, SizeCodes } from 'src/database/entities/size.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class SizeSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Size)
    private readonly SizeRepository: Repository<Size>,
  ) {}

  async seed() {
    const data: Partial<Size>[] = this.generateData();
    await this.SizeRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Size>[] {
    const data: Partial<Size>[] = [];
    Object.keys(SizeCodes).forEach((key) => {
      data.push({
        code: SizeCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/typeorm/typeOrm.config.ts

```typescript
/* eslint-disable prettier/prettier */
import { DataSource, DataSourceOptions } from 'typeorm';
import { config } from 'dotenv';

// Carga .env solo si estamos en local y no en producción (donde ya existen las vars)
if (process.env.NODE_ENV !== 'production') {
  config(); 
}

export const dataSourceOptions: DataSourceOptions = {
  type: 'postgres',
  host: process.env.DATABASE_HOST,
  port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
  database: process.env.DATABASE_NAME,
  username: process.env.DATABASE_USER,
  password: process.env.DATABASE_PASSWORD,
  entities: ['dist/**/*.entity.js'], // Apuntamos a dist para producción
  migrations: ['dist/database/migration/history/*.js'],
  synchronize: false, 
  logging: process.env.NODE_ENV === 'development',
};

// Default export para CLI de TypeORM
const datasource = new DataSource(dataSourceOptions);
export default datasource;
```

## src/database/typeorm/typeorm.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import { TypeOrmOptionsFactory, TypeOrmModuleOptions } from '@nestjs/typeorm';
import { dataSourceOptions } from 'src/database/typeorm/typeOrm.config';

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  public createTypeOrmOptions(): TypeOrmModuleOptions {
    return dataSourceOptions;
  }
}
```

## src/errors/custom/index.ts

```typescript
export interface ErrorBody extends Error {
  code: string;
}
//corrijo errores de texto wronCredentials por wrongCredentials
//invlidToken por invalidToken
export const errorMessages = {
  auth: {
    wrongCredentials: {
      message: 'wrong data provided',
      code: '60001',
    },
    userAlreadyExist: {
      message: 'user already exist',
      code: '60002',
    },
    expiredToken: {
      message: 'token expired',
      code: '60003',
    },
    invalidToken: {
      message: 'invalid token',
      code: '60004',
    },
    notAllowed: {
      message: 'not allowed',
      code: '60005',
    },
  },
  user: {
    notFound: {
      message: 'user not found',
      code: '60101',
    },
  },
  role: {
    notFound: {
      message: 'role not found',
      code: '60201',
    },
  },
  category: {
    notFound: {
      message: 'category not found',
      code: '60301',
    },
  },
  product: {
    notFound: {
      message: 'product not found',
      code: '60401',
    },
    notFulfilled: {
      message: 'not all product info is fulfilled',
      code: '60402',
    },
  },
  global: {
    internalError: {
      message: 'something went wrong',
      code: '70000',
    },
  },
};
```

## src/errors/errors.filter.ts

```typescript
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';
import { ErrorBody, errorMessages } from './custom';

@Catch()
export class ErrorsFilter implements ExceptionFilter {
  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

  catch(exception: Error, host: ArgumentsHost): void {
    Logger.error(exception.message);
    const { httpAdapter } = this.httpAdapterHost;

    const ctx = host.switchToHttp();
    if (exception instanceof HttpException) {
      const message = exception.message;
      const httpStatus =
        exception.getStatus() || HttpStatus.INTERNAL_SERVER_ERROR;
      const errorMessage = (exception.getResponse() as HttpException).message;
      const errorCode = (exception.getResponse() as ErrorBody).code || '60400';
      const errors = Array.isArray(errorMessage)
        ? errorMessage
        : [errorMessage];
      const responseBody = {
        isSuccess: false,
        message,
        errorCode,
        data: null,
        errors,
      };

      httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);
    } else {
      const responseBody = {
        isSuccess: false,
        message: errorMessages.global.internalError.message,
        errorCode: errorMessages.global.internalError.code,
        data: null,
        errors: [errorMessages.global.internalError.message],
      };

      httpAdapter.reply(
        ctx.getResponse(),
        responseBody,
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
```

## src/main.ts

```typescript
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe({ transform: true }));
  await app.listen(3000);
}
bootstrap();
```

## Statistics

- Total Files: 72
- Total Characters: 242668
- Total Tokens: 0
```````

## src/api/api.module.ts

```typescript
import { Module } from '@nestjs/common';
import { APP_FILTER, APP_INTERCEPTOR } from '@nestjs/core';
import { SucessResponseInterceptor } from 'src/common/helper/success-response.interceptor';
import { AuthModule } from './auth/auth.module';
import { UserModule } from './user/user.module';
import { RoleModule } from './role/role.module';
import { ProductModule } from './product/product.module';
import { ErrorsFilter } from 'src/errors/errors.filter';
import { InventoryModule } from './inventory/inventory.module';

@Module({
  imports: [AuthModule, UserModule, RoleModule, ProductModule, InventoryModule],
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: SucessResponseInterceptor,
    },
    {
      provide: APP_FILTER,
      useClass: ErrorsFilter,
    },
  ],
})
export class ApiModule {}
```

## src/api/auth/auth.module.ts

```typescript
import { Module } from '@nestjs/common';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { RoleModule } from '../role/role.module';
import { AuthController } from './controllers/auth.controller';
import { AuthService } from './services/auth.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [
    UserModule,
    TypeOrmModule.forFeature([User]),
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '3h' },
    }),
    RoleModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, UserService],
  exports: [],
})
export class AuthModule {}
```

## src/api/auth/controllers/auth.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from '../services/auth.service';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;
  let fakeAuthService: Partial<AuthService>;

  beforeEach(async () => {
    fakeAuthService = {
      register: () => {
        return Promise.resolve({
          message: 'success',
        });
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: fakeAuthService,
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/auth/controllers/auth.controller.ts

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { CreateUserDto } from 'src/api/user/dto/user.dto';
import { AuthService } from '../services/auth.service';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  login(@Body() user: CreateUserDto) {
    return this.authService.login(user);
  }

  @Post('register')
  register(@Body() user: CreateUserDto) {
    return this.authService.register(user);
  }
}
```

## src/api/auth/dto/auth.dto.ts

```typescript
import { IsNotEmpty } from 'class-validator';

export class PayloadDto {
  @IsNotEmpty()
  public email: string;

  @IsNotEmpty()
  public id: number;
}
```

## src/api/auth/guards/auth.decorator.ts

```typescript
import { applyDecorators, SetMetadata, UseGuards } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { RolesGuard } from './roles.guard';

export function Auth(...roleIds: number[]) {
  return applyDecorators(
    SetMetadata('roleIds', roleIds),
    UseGuards(AuthGuard, RolesGuard),
  );
}
```

## src/api/auth/guards/roles.guard.ts

```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private readonly userService: UserService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const roles = this.reflector.get<number[]>('roleIds', context.getHandler());
    if (roles.length === 0) return true;
    const request = context.switchToHttp().getRequest();
    if (!request.user.roles.some((userRole) => roles.includes(userRole.id)))
      throw new UnauthorizedException(errorMessages.auth.notAllowed);

    return true;
  }
}
```

## src/api/auth/guards/user.decorator.ts

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from 'src/database/entities/user.entity';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext): User => {
    const req = context.switchToHttp().getRequest();
    return req.user;
  },
);
```

## src/api/inventory/controllers/inventory.controller.ts

```typescript
/* eslint-disable prettier/prettier */
import { Controller, Get, Param, ParseIntPipe } from '@nestjs/common';
import { InventoryService } from '../services/inventory.service';
//import { Auth } from 'src/api/auth/guards/auth.decorator';
// Importamos Auth para proteger la ruta, aunque sea de lectura (opcional según regla de negocio)

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @Get('product/:id')
  async getProductStock(@Param('id', ParseIntPipe) productId: number) {
    return this.inventoryService.getStockByProduct(productId);
  }
}
```

## src/api/inventory/inventory.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';
import { InventoryController } from './controllers/inventory.controller';
import { InventoryService } from './services/inventory.service';
import { InventoryProcessor } from './inventory.processor'; // <--- Importamos

@Module({
  imports: [
    TypeOrmModule.forFeature([Inventory, ProductVariation]),
  ],
  controllers: [InventoryController],
  providers: [InventoryService, 
    InventoryProcessor // Registramos el processor como provider (importante )

  ],
  exports: [InventoryService], // Exportamos el servicio para usarlo en otros lados si hiciera falta
})
export class InventoryModule {}
```

## src/api/inventory/inventory.processor.ts

```typescript
/* eslint-disable prettier/prettier */
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { Logger } from '@nestjs/common';
import { InventoryService } from './services/inventory.service';

@Processor('catalog-queue')
export class InventoryProcessor extends WorkerHost {
  private readonly logger = new Logger(InventoryProcessor.name);

  constructor(private readonly inventoryService: InventoryService) {
    super();
  }

  async process(job: Job<any, any, string>): Promise<any> {
    this.logger.log(`⚡ Evento recibido: ${job.name} | JobId: ${job.id}`);

    switch (job.name) {
      case 'product.created':
        return this.handleProductCreated(job);
      case 'product.deleted':
        return this.handleProductDeleted(job);
      default:
        this.logger.warn(`Evento desconocido ignorado: ${job.name}`);
    }
  }

  // Manejo del Evento 1
  private async handleProductCreated(job: Job) {
    const { productId } = job.data;
    this.logger.log(`📦 Creando inventario inicial para Producto ID: ${productId}...`);
    
    try {
      // Aquí simulamos la creación. En un caso real, ProductService debería enviar 
      // el ID de la "Variación" (Talla/Color), no solo del Producto padre.
      // Como el challenge pide "base razonable", asumiremos que creamos stock 
      // para una variación placeholder o manejamos la lógica aquí.
      
      // Llamada al servicio de inventario (que implementaremos abajo)
      await this.inventoryService.createInitialStock(productId);
      
      this.logger.log(`✅ Inventario creado exitosamente para Producto ID: ${productId}`);
    } catch (error) {
      this.logger.error(`❌ Error creando inventario: ${error.message}`);
      // BullMQ reintentará esto automáticamente si fallamos aquí
      throw error; 
    }
  }

  // Manejo del Evento 2
  private async handleProductDeleted(job: Job) {
    const { productId } = job.data;
    this.logger.warn(`🗑️ Producto ${productId} eliminado. Limpiando stock asociado...`);
    
    // Aquí llamaríamos a un método de servicio para borrar/archivar
    // await this.inventoryService.removeStockForProduct(productId);
    
    // Simulamos un delay para ver la asincronía
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    this.logger.log(`✅ Stock del producto ${productId} eliminado correctamente.`);
  }
}
```

## src/api/inventory/services/inventory.service.ts

```typescript
/* eslint-disable prettier/prettier */
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';

@Injectable()
export class InventoryService {
  private readonly logger = new Logger(InventoryService.name);

  constructor(
    @InjectRepository(Inventory)
    private readonly inventoryRepo: Repository<Inventory>,
    @InjectRepository(ProductVariation)
    private readonly variationRepo: Repository<ProductVariation>,
  ) {}

  /**
   * Maneja el evento 'product.created'.
   * Intenta inicializar stock si existen variaciones, o simula la accion.
   */
  async createInitialStock(productId: number) {
    // 1. Buscamos si el producto ya tiene variaciones (ej. si se crearon en la misma transaccion)
    const variations = await this.variationRepo.find({
      where: { productId },
    });

    const countryCode = 'EG'; // Hardcodeado por reglas de negocio actuales

    // CASO A: El producto se creo pero aon no tiene Talla/Color definido.
    if (variations.length === 0) {
      this.logger.log(
        `[LOGIC] El producto ID ${productId} no tiene variaciones aún. No se puede crear registro en tabla 'Inventory' por restricción de FK.`,
      );
      this.logger.log(`[SIMULATION] Se reserva espacio lógico de inventario para Producto ${productId}.`);
      return;
    }

    // CASO B: (Edge Case) El producto ya tiene variaciones, creamos stock en 0 para cada una.
    const inventoryEntities = variations.map((variation) => {
      return this.inventoryRepo.create({
        productVariationId: variation.id,
        countryCode: countryCode,
        quantity: 0, // Stock inicial por defecto
      });
    });

    await this.inventoryRepo.save(inventoryEntities);
    this.logger.log(`✅ Stock inicial (0) creado para ${variations.length} variaciones del producto ${productId}.`);
  }

  /*
    Maneja el evento 'product.deleted'.
    Elimina todo registro de inventario asociado a las variaciones de ese producto.
   */
  async deleteStockForProduct(productId: number) {
    // Usamos QueryBuilder para hacer un DELETE con Subquery, es mas eficiente que buscar y borrar uno por uno.
    // SQL Equivalente: DELETE FROM inventory WHERE productVariationId IN (SELECT id FROM product_variation WHERE productId = X)
    
    const variations = await this.variationRepo.find({ where: { productId }, select: ['id'] });
    
    if (variations.length === 0) {
        this.logger.log(`No hay stock que limpiar para el producto ${productId}`);
        return;
    }

    const variationIds = variations.map(v => v.id);

    const result = await this.inventoryRepo
      .createQueryBuilder()
      .delete()
      .from(Inventory)
      .where('productVariationId IN (:...ids)', { ids: variationIds })
      .execute();

    this.logger.log(`🗑️ Eliminados ${result.affected} registros de inventario para el producto ${productId}.`);
  }

  // --- Metodos de Lectura (Frontend) ---

  async getStockByProduct(productId: number) {
    // Buscamos todas las variaciones de un producto
    const variations = await this.variationRepo.find({
      where: { productId },
      relations: ['product'], // Opcional, si necesitas datos del padre
    });

    if (!variations.length) {
      return { productId, totalStock: 0, breakdown: [], message: 'No variations found' };
    }

    const variationIds = variations.map((v) => v.id);

    // Buscamos el stock de esas variaciones
    const stockItems = await this.inventoryRepo
      .createQueryBuilder('inventory')
      .where('inventory.productVariationId IN (:...ids)', { ids: variationIds })
      .getMany();

    const totalStock = stockItems.reduce((acc, item) => acc + item.quantity, 0);

    return {
      productId,
      totalStock,
      breakdown: stockItems,
    };
  }
}
```

## src/api/product/controllers/product.controller.ts

```typescript
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { RoleIds } from '../../role/enum/role.enum';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { ProductService } from '../services/product.service';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { FindOneParams } from 'src/common/helper/findOneParams.dto';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { User } from 'src/database/entities/user.entity';

@Controller('product')
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Get(':id')
  async getProduct(@Param() product: FindOneParams) {
    return this.productService.getProduct(product.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post('create')
  async createProduct(
    @Body() body: CreateProductDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.createProduct(body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/details')
  async addProductDetails(
    @Param() product: FindOneParams,
    @Body() body: ProductDetailsDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.addProductDetails(product.id, body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/activate')
  async activateProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.activateProduct(product.id, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Delete(':id')
  async deleteProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.deleteProduct(product.id, user.id);
  }
}
```

## src/api/product/dto/product.dto.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsIn,
  IsNotEmpty,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import { variationTypesKeys } from 'src/database/entities/product.entity';
import { ProductDetails, ProductDetailsTypeFn } from './productDetails';

export class CreateProductDto {
  @IsNumber()
  @IsNotEmpty()
  public categoryId: number;
}

export class ProductDetailsDto {
  @IsString()
  @IsNotEmpty()
  public title: string;

  @IsString()
  @IsNotEmpty()
  public code: string;

  @IsDefined()
  @IsString()
  @IsIn(variationTypesKeys)
  public variationType: string;

  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: ProductDetails;

  @ArrayMinSize(1)
  @IsString({ each: true })
  public about: string[];

  @IsString()
  @IsNotEmpty()
  public description: string;
}
```

## src/api/product/dto/productDetails/computer.details.ts

```typescript
import { IsIn, IsNotEmpty, IsNumber, IsString } from 'class-validator';
import { Categories } from 'src/database/entities/category.entity';

export class ComputerDetails {
  @IsString()
  @IsNotEmpty()
  category = Categories.Computers;

  @IsNumber()
  capacity: number;

  @IsString()
  @IsIn(['GB', 'TB'])
  capacityUnit: 'GB' | 'TB';

  @IsString()
  @IsIn(['SSD', 'HD'])
  capacityType: 'SSD' | 'HD';

  @IsString()
  @IsNotEmpty()
  brand: string;

  @IsString()
  @IsNotEmpty()
  series: string;
}
```

## src/api/product/dto/productDetails/index.ts

```typescript
import { BadRequestException } from '@nestjs/common';
import { TypeHelpOptions } from 'class-transformer';
import { Categories } from 'src/database/entities/category.entity';
import { ComputerDetails } from './computer.details';
import { TestDetails } from './test.details';

export type ProductDetails = ComputerDetails | TestDetails;

export function ProductDetailsTypeFn(options: TypeHelpOptions) {
  switch (options.object?.details?.category) {
    case Categories.Computers:
      return ComputerDetails;
    case 'Test':
      return TestDetails;
  }

  throw new BadRequestException('invalid details.category input');
}
```

## src/api/product/dto/productDetails/test.details.ts

```typescript
export class TestDetails {
  category = 'Test';
  test: boolean;
}
```

## src/api/product/product.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ProductService } from './services/product.service';
import { ProductController } from './controllers/product.controller';
import { Category } from '../../database/entities/category.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { Product } from 'src/database/entities/product.entity';
import { BullModule } from '@nestjs/bullmq'; 
@Module({
  imports: [TypeOrmModule.forFeature([User, Product, Category]), UserModule,
 // Registramos la cola donde vamos a publicar mensajes
    BullModule.registerQueue({
      name: 'catalog-queue',
    }),],
  controllers: [ProductController],
  providers: [ProductService],
})
export class ProductModule {}
```

## src/api/product/services/product.service.ts

```typescript
/* eslint-disable prettier/prettier */
import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { EntityManager } from 'typeorm';
import { InjectEntityManager } from '@nestjs/typeorm';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { Category } from '../../../database/entities/category.entity';
import { Product } from 'src/database/entities/product.entity';
import { errorMessages } from 'src/errors/custom';
import { validate } from 'class-validator';
import { successObject } from 'src/common/helper/success-response.interceptor';
import { InjectQueue } from '@nestjs/bullmq'; // <--- Importamos
import { Queue } from 'bullmq'; // <--- Importamos 

@Injectable()
export class ProductService {
  constructor(
    @InjectEntityManager()
    private readonly entityManager: EntityManager,
    // Inyectamos la cola definida en el modulo
    @InjectQueue('catalog-queue') private readonly catalogQueue: Queue,
  ) {}

  async getProduct(productId: number) {
    const product = await this.entityManager.findOne(Product, {
      where: {
        id: productId,
      },
    });

    if (!product) throw new NotFoundException(errorMessages.product.notFound);

    return product;
  }

 async createProduct(data: CreateProductDto, merchantId: number) {
    const category = await this.entityManager.findOne(Category, {
      where: { id: data.categoryId },
    });
    if (!category) throw new NotFoundException(errorMessages.category.notFound);

    const product = await this.entityManager.create(Product, {
      category,
      merchantId,
    });

    const savedProduct = await this.entityManager.save(product);

    // --- EVENTO 1: PRODUCTO CREADO ---
    // Publicamos el evento a Redis. Esto es asíncrono y desacoplado.
    await this.catalogQueue.add('product.created', {
      productId: savedProduct.id,
      merchantId: merchantId,
      sku: savedProduct.code // Si tuvieras SKU
    });
    // ---------------------------------

    return savedProduct;
  }
  async addProductDetails(
    productId: number,
    body: ProductDetailsDto,
    merchantId: number,
  ) {
    const result = await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({
        ...body,
      })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute();
    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);
    return await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({ ...body })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute().then(res => res.raw[0]);
  }
  async activateProduct(productId: number, merchantId: number) {
    if (!(await this.validate(productId)))
      throw new ConflictException(errorMessages.product.notFulfilled);

    return await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({ isActive: true })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id', 'isActive'])
      .execute().then(res => res.raw[0]);
  }

  async validate(productId: number) {
     const product = await this.entityManager.findOne(Product, { where: { id: productId } });
    if (!product) throw new NotFoundException(errorMessages.product.notFound);
    const errors = await validate(product);
    return errors.length === 0;
  }

  async deleteProduct(productId: number, merchantId: number) {
    const result = await this.entityManager
      .createQueryBuilder()
      .delete()
      .from(Product)
      .where('id = :productId', { productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .execute();

    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);

    // Si se borró con éxito, avisamos al inventario para que limpie
    await this.catalogQueue.add('product.deleted', {
      productId: productId,
    });
    // ------------------------------------

    return successObject;
  }
}
```

## src/api/role/controllers/role.controller.spec.ts

```typescript
import { ConfigModule } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { configuration } from 'src/config';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { AuthModule } from '../../auth/auth.module';
import { RoleController } from './role.controller';
import { Role } from '../../../database/entities/role.entity';
import { RoleIds, Roles } from '../enum/role.enum';
import { RoleService } from '../services/role.service';
import { UserService } from 'src/api/user/services/user.service';

describe('RoleController', () => {
  let controller: RoleController;
  let fakeRoleService: Partial<RoleService>;
  let fakeUserService: Partial<UserService>;

  const customerRole = {
    id: RoleIds.Customer,
    name: Roles.Customer,
  } as Role;

  beforeEach(async () => {
    fakeRoleService = {
      findById: () => {
        return Promise.resolve(customerRole);
      },
    };
    fakeUserService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [RoleController],
      providers: [
        {
          provide: RoleService,
          useValue: fakeRoleService,
        },
        {
          provide: UserService,
          useValue: fakeUserService,
        },
      ],
      imports: [
        AuthModule,
        ConfigModule.forRoot({ load: [configuration], isGlobal: true }),
        TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
      ],
    }).compile();

    controller = module.get<RoleController>(RoleController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/role/controllers/role.controller.ts

```typescript
import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { AssignRoleDto } from '../dto/role.dto';
import { RoleIds } from '../enum/role.enum';
import { RoleService } from '../services/role.service';

@Controller('role')
export class RoleController {
  constructor(private readonly roleService: RoleService) {}

  @Auth(RoleIds.Admin)
  @Post('assign')
  async assignRoleToUser(@Body() body: AssignRoleDto) {
    return this.roleService.assignRoleToUser(body);
  }
}
```

## src/api/role/dto/role.dto.ts

```typescript
import { IsNotEmpty, IsNumber } from 'class-validator';

export class AssignRoleDto {
  @IsNumber()
  @IsNotEmpty()
  public userId: number;

  @IsNumber()
  @IsNotEmpty()
  public roleId: number;
}
```

## src/api/role/enum/role.enum.ts

```typescript
export enum RoleIds {
  Customer = 1,
  Merchant,
  Admin,
}

export enum Roles {
  Customer = 'Customer',
  Merchant = 'Merchant',
  Admin = 'Admin',
}
```

## src/api/role/role.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Role } from '../../database/entities/role.entity';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { RoleController } from './controllers/role.controller';
import { RoleService } from './services/role.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [TypeOrmModule.forFeature([Role, User]), UserModule],
  controllers: [RoleController],
  providers: [RoleService, UserService],
  exports: [RoleService],
})
export class RoleModule {}
```

## src/api/role/services/role.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Role } from 'src/database/entities/role.entity';
import { AssignRoleDto } from '../dto/role.dto';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RoleService {
  constructor(
    @InjectRepository(Role) private readonly rolesRepository: Repository<Role>,
    private readonly userService: UserService,
  ) {}

  async assignRoleToUser(data: AssignRoleDto) {
    const role = await this.findById(data.roleId);
    const user = await this.userService.findById(data.userId, { roles: true });
    if (!user.roles.some((userRole) => userRole.id === data.roleId)) {
      user.roles.push(role);
    }
    return this.userService.save(user);
  }

  async findById(roleId: number) {
    const role = await this.rolesRepository.findOne({
      where: {
        id: roleId,
      },
    });
    if (!role) {
      throw new NotFoundException(errorMessages.role.notFound);
    }
    return role;
  }
}
```

## src/api/user/controllers/user.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { Serialize } from 'src/common/helper/serialize.interceptor';
import { User } from 'src/database/entities/user.entity';
import { UserDto } from '../dto/user.dto';
import { UserService } from '../services/user.service';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Auth()
  @Serialize(UserDto)
  @Get('profile')
  profile(@CurrentUser() user: User) {
    return this.userService.findById(user.id);
  }
}
```

## src/api/user/dto/user.dto.ts

```typescript
import { Expose } from 'class-transformer';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  public email: string;

  @IsString()
  @IsNotEmpty()
  public password: string;
}

export class UserDto {
  @Expose()
  public id: number;

  @Expose()
  public email: string;
}
```

## src/api/user/dto/user.types.ts

```typescript
export type UserRelation = {
  roles: boolean;
};
```

## src/api/user/services/user.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { Repository } from 'typeorm';
import { hash, compare } from 'bcrypt';
import { InjectRepository } from '@nestjs/typeorm';
import { User } from 'src/database/entities/user.entity';
import { CreateUserDto } from '../dto/user.dto';
import { Role } from 'src/database/entities/role.entity';
import { UserRelation } from '../dto/user.types';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User) private readonly repository: Repository<User>,
  ) {}

  public async createUser(
    body: CreateUserDto,
    ...roles: Role[]
  ): Promise<User> {
    body.password = await hash(body.password, 10);
    const user: User = this.repository.create({
      ...body,
      roles,
    });

    return this.repository.save(user);
  }

  public async findByEmail(
    email: string,
    relations?: UserRelation,
  ): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        email,
      },
      relations,
    });
    return user;
  }

  public async comparePassword(password, userPassword): Promise<boolean> {
    return compare(password, userPassword);
  }

  public async findById(id: number, relations?: UserRelation): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        id,
      },
      relations,
    });
    if (!user) {
      throw new NotFoundException(errorMessages.user.notFound);
    }
    return user;
  }

  public async save(user: User) {
    return this.repository.save(user);
  }
}
```

## src/api/user/user.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../../database/entities/user.entity';
import { UserController } from './controllers/user.controller';
import { UserService } from './services/user.service';

@Module({
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
  imports: [TypeOrmModule.forFeature([User])],
})
export class UserModule {}
```

## src/app.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
```

## src/app.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

## src/app.module.ts

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config'; // Asegúrate de importar ConfigService
import { TypeOrmModule } from '@nestjs/typeorm';
import { BullModule } from '@nestjs/bullmq';
import * as Joi from 'joi';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { TypeOrmConfigService } from './database/typeorm/typeorm.service';
import { ApiModule } from './api/api.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      validationSchema: Joi.object({
        NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),
        PORT: Joi.number().default(3000),
        DATABASE_HOST: Joi.string().required(),
        DATABASE_PORT: Joi.number().default(5432),
        DATABASE_USER: Joi.string().required(),
        DATABASE_PASSWORD: Joi.string().required(),
        DATABASE_NAME: Joi.string().required(),
        JWT_SECRET: Joi.string().required(),
        REDIS_HOST: Joi.string().default('127.0.0.1'),
        REDIS_PORT: Joi.number().default(6379),
      }),
    }),
    
    // Configuración BLINDADA de BullMQ
    BullModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const host = configService.get<string>('REDIS_HOST');
        const port = configService.get<number>('REDIS_PORT');
        
        console.log(`[BullMQ] Intentando conectar a Redis en: ${host}:${port}`);
        
        return {
          connection: {
            host: host,
            port: Number(port), // Forzamos que sea numero sí o sí
          },
        };
      },
      inject: [ConfigService],
    }),

    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    ApiModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

## src/app.service.ts

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
```

## src/common/helper/findOneParams.dto.ts

```typescript
import { IsNumberString } from 'class-validator';

export class FindOneParams {
  @IsNumberString()
  id: number;
}
```

## src/common/helper/serialize.interceptor.ts

```typescript
import {
  UseInterceptors,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { plainToInstance } from 'class-transformer';

interface ClassConstructor {
  new (...args: any[]): any;
}

export function Serialize(dto: ClassConstructor) {
  return UseInterceptors(new SerializeInterceptor(dto));
}

export class SerializeInterceptor implements NestInterceptor {
  constructor(private dto: any) {}

  intercept(context: ExecutionContext, handler: CallHandler): Observable<any> {
    return handler.handle().pipe(
      map((data: any) => {
        return plainToInstance(this.dto, data, {
          excludeExtraneousValues: true,
        });
      }),
    );
  }
}
```

## src/common/helper/success-response.interceptor.ts

```typescript
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { map, Observable } from 'rxjs';

@Injectable()
export class SucessResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        return {
          isSuccess: true,
          message: 'success',
          data,
          errorCode: null,
          errors: [],
        };
      }),
    );
  }
}

export const successObject = {
  message: 'success',
};
```

## src/database/entities/category.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  PrimaryColumn,
} from 'typeorm';
import { Product } from './product.entity';

@Entity()
export class Category {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar' })
  public name: string;

  @OneToMany(() => Product, (product) => product.category)
  products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CategoryIds {
  Computers = 1,
  Fashion,
}

export enum Categories {
  Computers = 'Computers',
  Fashion = 'Fashion',
}
```

## src/database/entities/color.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Color {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public name!: string;

  @Column({ type: 'varchar', length: 10 })
  public hexCode: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum Colors {
  NA = 'NA',
  Red = 'red',
  Green = 'green',
  Blue = 'blue',
}

export enum ColorsHexCodes {
  NA = 'NA',
  Red = '#FF0000',
  Green = '#00FF00',
  Blue = '#0000FF',
}
```

## src/database/entities/country.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Country {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CountryCodes {
  Egypt = 'EG',
}

export enum Countries {
  Egypt = 'Egypt',
}
```

## src/database/entities/currency.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Currency {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CurrencyCodes {
  EGP = 'EGP',
}

export enum CurrencyNames {
  EGP = 'Egyptian Pound',
}
```

## src/database/entities/inventory.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class Inventory {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @Column({ type: 'int' })
  public quantity: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/product.entity.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import {
  ProductDetails,
  ProductDetailsTypeFn,
} from 'src/api/product/dto/productDetails';
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  JoinColumn,
  Index,
} from 'typeorm';
import { Category } from './category.entity';
import { User } from './user.entity';

@Entity()
export class Product {
  @PrimaryGeneratedColumn()
  @IsDefined()
  @IsNumber()
  public id!: number;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  @Index()
  public code: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public title: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public variationType: string;

  @Column({ type: 'text', nullable: true })
  @IsDefined()
  @IsString()
  public description?: string | null;

  @Column({ type: 'text', array: true, default: [] })
  @ArrayMinSize(1)
  @IsString({ each: true })
  public about?: string[];

  @Column({ type: 'jsonb', nullable: true })
  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: Partial<ProductDetails> | null;

  @Column({ default: false })
  public isActive: boolean;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public merchantId: number;

  @ManyToOne(() => User, (user) => user.products)
  @JoinColumn({ name: 'merchantId' })
  public merchant: User;

  @ManyToOne(() => Category, (category) => category.products)
  @JoinColumn({ name: 'categoryId' })
  public category: Category;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public categoryId: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum VariationTypes {
  NONE = 'NONE',
  OnlySize = 'OnlySize',
  OnlyColor = 'OnlyColor',
  SizeAndColor = 'SizeAndColor',
}
export const variationTypesKeys = Object.keys(VariationTypes);
```

## src/database/entities/productVariation.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Color } from './color.entity';
import { Product } from './product.entity';
import { Size } from './size.entity';

@Entity()
export class ProductVariation {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => Product)
  @JoinColumn({ name: 'productId' })
  public product: Product;

  @Column({ type: 'int' })
  public productId: number;

  @ManyToOne(() => Size)
  @JoinColumn({ name: 'sizeCode' })
  public size: Size;

  @Column({ type: 'varchar', length: 7 })
  public sizeCode: string;

  @ManyToOne(() => Color)
  @JoinColumn({ name: 'colorName' })
  public color: Color;

  @Column({ type: 'varchar', length: 30 })
  public colorName: string;

  @Column({ type: 'text', array: true, default: [] })
  public imageUrls: string[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/productVariation_price.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { Currency } from './currency.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class ProductVariationPrice {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @ManyToOne(() => Currency)
  @JoinColumn({ name: 'currencyCode' })
  public currency: Currency;

  @Column({ type: 'varchar', length: 7 })
  public currencyCode: string;

  @Column({ type: 'float' })
  public price: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/role.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
  ManyToMany,
} from 'typeorm';
import { User } from './user.entity';

@Entity()
export class Role {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public name: string;

  @ManyToMany(() => User, (user) => user.roles)
  public users: User[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/size.entity.ts

```typescript
import {
  Entity,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Size {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public code!: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum SizeCodes {
  NA = 'NA',
  Small = 'S',
  Medium = 'M',
  Large = 'L',
  XLarge = 'XL',
  XXLarge = 'XXL',
}
```

## src/database/entities/user.entity.ts

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToMany,
  JoinTable,
  OneToMany,
} from 'typeorm';
import { Product } from './product.entity';
import { Role } from './role.entity';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public email: string;

  @Column({ type: 'varchar' })
  public password: string;

  @ManyToMany(() => Role, (role) => role.users)
  @JoinTable({ name: 'user_roles' })
  public roles: Role[];

  @OneToMany(() => Product, (product) => product.merchant)
  public products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/migration/datasource.ts

```typescript
import { DataSource } from 'typeorm';
import { dataSourceOptions } from '../typeorm/typeOrm.config';

const datasource = new DataSource(dataSourceOptions);

export default datasource;
```

## src/database/seed/seed.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Category } from 'src/database/entities/category.entity';
import { Role } from 'src/database/entities/role.entity';
import { User } from 'src/database/entities/user.entity';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { Color } from '../entities/color.entity';
import { Country } from '../entities/country.entity';
import { Currency } from '../entities/currency.entity';
import { Size } from '../entities/size.entity';
import { SeedService } from './seed.service';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';
//  La importación 'configuration' ha sido eliminada

@Module({
  imports: [
    // Agregamos ConfigModule para que lea el .env al ejecutar seeds
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    TypeOrmModule.forFeature([
      Role,
      User,
      Category,
      Size,
      Color,
      Country,
      Currency,
    ]),
  ],
  controllers: [],
  providers: [
    SeedService,
    RolesSeeder,
    AdminSeeder,
    CategorySeeder,
    SizeSeeder,
    ColorSeeder,
    CountrySeeder,
    CurrencySeeder,
  ],
})
export class SeedModule {}
```

## src/database/seed/seed.service.ts

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Promise as Bluebird } from 'bluebird';
import { SeederInterface } from './seeder.interface';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';

@Injectable()
export class SeedService {
  private readonly seeders: SeederInterface[] = [];
  private readonly logger = new Logger(SeedService.name);

  constructor(
    rolesSeeder: RolesSeeder,
    adminSeeder: AdminSeeder,
    categoriesSeeder: CategorySeeder,
    sizesSeeder: SizeSeeder,
    colorsSeeder: ColorSeeder,
    countrySeeder: CountrySeeder,
    currencySeeder: CurrencySeeder,
  ) {
    this.seeders = [
      rolesSeeder,
      adminSeeder,
      categoriesSeeder,
      sizesSeeder,
      colorsSeeder,
      countrySeeder,
      currencySeeder,
    ];
  }

  async seed() {
    await Bluebird.each(this.seeders, async (seeder: SeederInterface) => {
      this.logger.log(`Seeding ${seeder.constructor.name}`);
      await seeder.seed();
    });
  }
}
```

## src/database/seed/seed.ts

```typescript
import { NestFactory } from '@nestjs/core';
import { SeedModule } from './seed.module';
import { SeedService } from './seed.service';

async function bootstrap() {
  const app = await NestFactory.create(SeedModule);
  const seedService = app.get(SeedService);
  await seedService.seed();
  await app.close();
}
bootstrap();
```

## src/database/seed/seeder.interface.ts

```typescript
export interface SeederInterface {
  seed(): Promise<void>;
}
```

## src/database/seed/seeders/category.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Categories,
  Category,
  CategoryIds,
} from 'src/database/entities/category.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CategorySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Category)
    private readonly categoriesRepository: Repository<Category>,
  ) {}

  async seed() {
    const data: Partial<Category>[] = this.generateData();
    await this.categoriesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Category>[] {
    const data: Partial<Category>[] = [];
    Object.keys(Categories).forEach((key) => {
      data.push({
        id: CategoryIds[key],
        name: Categories[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/color.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Color,
  Colors,
  ColorsHexCodes,
} from 'src/database/entities/color.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class ColorSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Color)
    private readonly colorsRepository: Repository<Color>,
  ) {}

  async seed() {
    const data: Partial<Color>[] = this.generateData();
    await this.colorsRepository.upsert(data, {
      conflictPaths: ['name'],
    });
  }

  generateData(): Partial<Color>[] {
    const data: Partial<Color>[] = [];
    Object.keys(Colors).forEach((key) => {
      data.push({
        name: Colors[key],
        hexCode: ColorsHexCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/country.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Countries,
  Country,
  CountryCodes,
} from 'src/database/entities/country.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CountrySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Country)
    private readonly countryRepository: Repository<Country>,
  ) {}

  async seed() {
    const data: Partial<Country>[] = this.generateData();
    await this.countryRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Country>[] {
    const data: Partial<Country>[] = [];
    Object.keys(Countries).forEach((key) => {
      data.push({
        code: CountryCodes[key],
        name: Countries[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/currency.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Currency,
  CurrencyCodes,
  CurrencyNames,
} from 'src/database/entities/currency.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CurrencySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Currency)
    private readonly currencyRepository: Repository<Currency>,
  ) {}

  async seed() {
    const data: Partial<Currency>[] = this.generateData();
    await this.currencyRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Currency>[] {
    const data: Partial<Currency>[] = [];
    Object.keys(CurrencyCodes).forEach((key) => {
      data.push({
        code: CurrencyCodes[key],
        name: CurrencyNames[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/role.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';
import { Role } from 'src/database/entities/role.entity';
import { RoleIds, Roles } from 'src/api/role/enum/role.enum';

@Injectable()
export class RolesSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Role)
    private readonly rolesRepository: Repository<Role>,
  ) {}

  async seed() {
    const data: Partial<Role>[] = this.generateData();
    await this.rolesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Role>[] {
    const data: Partial<Role>[] = [];
    Object.keys(Roles).forEach((key) => {
      data.push({
        id: RoleIds[key],
        name: Roles[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/size.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Size, SizeCodes } from 'src/database/entities/size.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class SizeSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Size)
    private readonly SizeRepository: Repository<Size>,
  ) {}

  async seed() {
    const data: Partial<Size>[] = this.generateData();
    await this.SizeRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Size>[] {
    const data: Partial<Size>[] = [];
    Object.keys(SizeCodes).forEach((key) => {
      data.push({
        code: SizeCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/typeorm/typeOrm.config.ts

```typescript
/* eslint-disable prettier/prettier */
import { DataSource, DataSourceOptions } from 'typeorm';
import { config } from 'dotenv';

// Carga .env solo si estamos en local y no en producción (donde ya existen las vars)
if (process.env.NODE_ENV !== 'production') {
  config(); 
}

export const dataSourceOptions: DataSourceOptions = {
  type: 'postgres',
  host: process.env.DATABASE_HOST,
  port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
  database: process.env.DATABASE_NAME,
  username: process.env.DATABASE_USER,
  password: process.env.DATABASE_PASSWORD,
  entities: ['dist/**/*.entity.js'], // Apuntamos a dist para producción
  migrations: ['dist/database/migration/history/*.js'],
  synchronize: false, 
  logging: process.env.NODE_ENV === 'development',
};

// Default export para CLI de TypeORM
const datasource = new DataSource(dataSourceOptions);
export default datasource;
```

## src/database/typeorm/typeorm.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import { TypeOrmOptionsFactory, TypeOrmModuleOptions } from '@nestjs/typeorm';
import { dataSourceOptions } from 'src/database/typeorm/typeOrm.config';

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  public createTypeOrmOptions(): TypeOrmModuleOptions {
    return dataSourceOptions;
  }
}
```

## src/errors/custom/index.ts

```typescript
export interface ErrorBody extends Error {
  code: string;
}
//corrijo errores de texto wronCredentials por wrongCredentials
//invlidToken por invalidToken
export const errorMessages = {
  auth: {
    wrongCredentials: {
      message: 'wrong data provided',
      code: '60001',
    },
    userAlreadyExist: {
      message: 'user already exist',
      code: '60002',
    },
    expiredToken: {
      message: 'token expired',
      code: '60003',
    },
    invalidToken: {
      message: 'invalid token',
      code: '60004',
    },
    notAllowed: {
      message: 'not allowed',
      code: '60005',
    },
  },
  user: {
    notFound: {
      message: 'user not found',
      code: '60101',
    },
  },
  role: {
    notFound: {
      message: 'role not found',
      code: '60201',
    },
  },
  category: {
    notFound: {
      message: 'category not found',
      code: '60301',
    },
  },
  product: {
    notFound: {
      message: 'product not found',
      code: '60401',
    },
    notFulfilled: {
      message: 'not all product info is fulfilled',
      code: '60402',
    },
  },
  global: {
    internalError: {
      message: 'something went wrong',
      code: '70000',
    },
  },
};
```

## src/errors/errors.filter.ts

```typescript
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';
import { ErrorBody, errorMessages } from './custom';

@Catch()
export class ErrorsFilter implements ExceptionFilter {
  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

  catch(exception: Error, host: ArgumentsHost): void {
    Logger.error(exception.message);
    const { httpAdapter } = this.httpAdapterHost;

    const ctx = host.switchToHttp();
    if (exception instanceof HttpException) {
      const message = exception.message;
      const httpStatus =
        exception.getStatus() || HttpStatus.INTERNAL_SERVER_ERROR;
      const errorMessage = (exception.getResponse() as HttpException).message;
      const errorCode = (exception.getResponse() as ErrorBody).code || '60400';
      const errors = Array.isArray(errorMessage)
        ? errorMessage
        : [errorMessage];
      const responseBody = {
        isSuccess: false,
        message,
        errorCode,
        data: null,
        errors,
      };

      httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);
    } else {
      const responseBody = {
        isSuccess: false,
        message: errorMessages.global.internalError.message,
        errorCode: errorMessages.global.internalError.code,
        data: null,
        errors: [errorMessages.global.internalError.message],
      };

      httpAdapter.reply(
        ctx.getResponse(),
        responseBody,
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
```

## src/main.ts

```typescript
/* eslint-disable prettier/prettier */
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // 1. Habilitar CORS (Justificación: Permite que el Front en localhost:5173 acceda a la API)
  app.enableCors({
    origin: 'http://localhost:5173', // URL por defecto de Vite
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  });

  // 2. Global Prefix (Opcional pero recomendado para Sr.)
  app.setGlobalPrefix('api');

  // 3. Pipes de Validación
  app.useGlobalPipes(new ValidationPipe({ 
    transform: true,
    whitelist: true, // Ignora propiedades que no esten en el DTO
    forbidNonWhitelisted: true, // Lanza error si envían datos de mas
  }));

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}

bootstrap();
```

## Statistics

- Total Files: 72
- Total Characters: 312028
- Total Tokens: 0
````````

## src/api/api.module.ts

```typescript
import { Module } from '@nestjs/common';
import { APP_FILTER, APP_INTERCEPTOR } from '@nestjs/core';
import { SucessResponseInterceptor } from 'src/common/helper/success-response.interceptor';
import { AuthModule } from './auth/auth.module';
import { UserModule } from './user/user.module';
import { RoleModule } from './role/role.module';
import { ProductModule } from './product/product.module';
import { ErrorsFilter } from 'src/errors/errors.filter';
import { InventoryModule } from './inventory/inventory.module';

@Module({
  imports: [AuthModule, UserModule, RoleModule, ProductModule, InventoryModule],
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: SucessResponseInterceptor,
    },
    {
      provide: APP_FILTER,
      useClass: ErrorsFilter,
    },
  ],
})
export class ApiModule {}
```

## src/api/auth/auth.module.ts

```typescript
import { Module } from '@nestjs/common';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { RoleModule } from '../role/role.module';
import { AuthController } from './controllers/auth.controller';
import { AuthService } from './services/auth.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [
    UserModule,
    TypeOrmModule.forFeature([User]),
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '3h' },
    }),
    RoleModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, UserService],
  exports: [],
})
export class AuthModule {}
```

## src/api/auth/controllers/auth.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from '../services/auth.service';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;
  let fakeAuthService: Partial<AuthService>;

  beforeEach(async () => {
    fakeAuthService = {
      register: () => {
        return Promise.resolve({
          message: 'success',
        });
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: fakeAuthService,
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/auth/controllers/auth.controller.ts

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { CreateUserDto } from 'src/api/user/dto/user.dto';
import { AuthService } from '../services/auth.service';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  login(@Body() user: CreateUserDto) {
    return this.authService.login(user);
  }

  @Post('register')
  register(@Body() user: CreateUserDto) {
    return this.authService.register(user);
  }
}
```

## src/api/auth/dto/auth.dto.ts

```typescript
import { IsNotEmpty } from 'class-validator';

export class PayloadDto {
  @IsNotEmpty()
  public email: string;

  @IsNotEmpty()
  public id: number;
}
```

## src/api/auth/guards/auth.decorator.ts

```typescript
import { applyDecorators, SetMetadata, UseGuards } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { RolesGuard } from './roles.guard';

export function Auth(...roleIds: number[]) {
  return applyDecorators(
    SetMetadata('roleIds', roleIds),
    UseGuards(AuthGuard, RolesGuard),
  );
}
```

## src/api/auth/guards/roles.guard.ts

```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private readonly userService: UserService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const roles = this.reflector.get<number[]>('roleIds', context.getHandler());
    if (roles.length === 0) return true;
    const request = context.switchToHttp().getRequest();
    if (!request.user.roles.some((userRole) => roles.includes(userRole.id)))
      throw new UnauthorizedException(errorMessages.auth.notAllowed);

    return true;
  }
}
```

## src/api/auth/guards/user.decorator.ts

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from 'src/database/entities/user.entity';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext): User => {
    const req = context.switchToHttp().getRequest();
    return req.user;
  },
);
```

## src/api/inventory/controllers/inventory.controller.ts

```typescript
/* eslint-disable prettier/prettier */
import { Controller, Get, Param, ParseIntPipe } from '@nestjs/common';
import { InventoryService } from '../services/inventory.service';
//import { Auth } from 'src/api/auth/guards/auth.decorator';
// Importamos Auth para proteger la ruta, aunque sea de lectura (opcional según regla de negocio)

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @Get('product/:id')
  async getProductStock(@Param('id', ParseIntPipe) productId: number) {
    return this.inventoryService.getStockByProduct(productId);
  }
  @Get()
async getAllInventory() {
  const inventory = await this.inventoryService.getAllInventory();
  return {
    message: 'Inventario recuperado exitosamente',
    data: inventory,
  };
}
}
```

## src/api/inventory/inventory.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';
import { InventoryController } from './controllers/inventory.controller';
import { InventoryService } from './services/inventory.service';
import { InventoryProcessor } from './inventory.processor'; // <--- Importamos

@Module({
  imports: [
    TypeOrmModule.forFeature([Inventory, ProductVariation]),
  ],
  controllers: [InventoryController],
  providers: [InventoryService, 
    InventoryProcessor // Registramos el processor como provider (importante )

  ],
  exports: [InventoryService], // Exportamos el servicio para usarlo en otros lados si hiciera falta
})
export class InventoryModule {}
```

## src/api/inventory/inventory.processor.ts

```typescript
/* eslint-disable prettier/prettier */
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { Logger } from '@nestjs/common';
import { InventoryService } from './services/inventory.service';

@Processor('catalog-queue')
export class InventoryProcessor extends WorkerHost {
  private readonly logger = new Logger(InventoryProcessor.name);

  constructor(private readonly inventoryService: InventoryService) {
    super();
  }

  async process(job: Job<any, any, string>): Promise<any> {
    this.logger.log(`⚡ Evento recibido: ${job.name} | JobId: ${job.id}`);

    switch (job.name) {
      case 'product.created':
        return this.handleProductCreated(job);
      case 'product.deleted':
        return this.handleProductDeleted(job);
      default:
        this.logger.warn(`Evento desconocido ignorado: ${job.name}`);
    }
  }

  // Manejo del Evento 1
  private async handleProductCreated(job: Job) {
    const { productId } = job.data;
    this.logger.log(`📦 Creando inventario inicial para Producto ID: ${productId}...`);
    
    try {
      // Aquí simulamos la creación. En un caso real, ProductService debería enviar 
      // el ID de la "Variación" (Talla/Color), no solo del Producto padre.
      // Como el challenge pide "base razonable", asumiremos que creamos stock 
      // para una variación placeholder o manejamos la lógica aquí.
      
      // Llamada al servicio de inventario (que implementaremos abajo)
      await this.inventoryService.createInitialStock(productId);
      
      this.logger.log(`✅ Inventario creado exitosamente para Producto ID: ${productId}`);
    } catch (error) {
      this.logger.error(`❌ Error creando inventario: ${error.message}`);
      // BullMQ reintentará esto automáticamente si fallamos aquí
      throw error; 
    }
  }

  // Manejo del Evento 2
  private async handleProductDeleted(job: Job) {
    const { productId } = job.data;
    this.logger.warn(`🗑️ Producto ${productId} eliminado. Limpiando stock asociado...`);
    
    // Aquí llamaríamos a un método de servicio para borrar/archivar
    // await this.inventoryService.removeStockForProduct(productId);
    
    // Simulamos un delay para ver la asincronía
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    this.logger.log(`✅ Stock del producto ${productId} eliminado correctamente.`);
  }
}
```

## src/api/inventory/services/inventory.service.ts

```typescript
/* eslint-disable prettier/prettier */
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';

@Injectable()
export class InventoryService {
  private readonly logger = new Logger(InventoryService.name);

  constructor(
    @InjectRepository(Inventory)
    private readonly inventoryRepo: Repository<Inventory>,
    @InjectRepository(ProductVariation)
    private readonly variationRepo: Repository<ProductVariation>,
  ) {}
  
  /**
   * Maneja el evento 'product.created'.
   * Intenta inicializar stock si existen variaciones, o simula la accion.
   */
  async getAllInventory(): Promise<Inventory[]> {
  // Retorna todos los registros de inventario
  return await this.inventoryRepo.find({
    order: { updatedAt: 'DESC' }
  });
}
  async createInitialStock(productId: number) {
    // 1. Buscamos si el producto ya tiene variaciones (ej. si se crearon en la misma transaccion)
    const variations = await this.variationRepo.find({
      where: { productId },
    });

    const countryCode = 'EG'; // Hardcodeado por reglas de negocio actuales

    // CASO A: El producto se creo pero aon no tiene Talla/Color definido.
    if (variations.length === 0) {
      this.logger.log(
        `[LOGIC] El producto ID ${productId} no tiene variaciones aún. No se puede crear registro en tabla 'Inventory' por restricción de FK.`,
      );
      this.logger.log(`[SIMULATION] Se reserva espacio lógico de inventario para Producto ${productId}.`);
      return;
    }
    
    // CASO B: (Edge Case) El producto ya tiene variaciones, creamos stock en 0 para cada una.
    const inventoryEntities = variations.map((variation) => {
      return this.inventoryRepo.create({
        productVariationId: variation.id,
        countryCode: countryCode,
        quantity: 0, // Stock inicial por defecto
      });
    });

    await this.inventoryRepo.save(inventoryEntities);
    this.logger.log(`✅ Stock inicial (0) creado para ${variations.length} variaciones del producto ${productId}.`);
  }

  /*
    Maneja el evento 'product.deleted'.
    Elimina todo registro de inventario asociado a las variaciones de ese producto.
   */
  async deleteStockForProduct(productId: number) {
    // Usamos QueryBuilder para hacer un DELETE con Subquery, es mas eficiente que buscar y borrar uno por uno.
    // SQL Equivalente: DELETE FROM inventory WHERE productVariationId IN (SELECT id FROM product_variation WHERE productId = X)
    
    const variations = await this.variationRepo.find({ where: { productId }, select: ['id'] });
    
    if (variations.length === 0) {
        this.logger.log(`No hay stock que limpiar para el producto ${productId}`);
        return;
    }

    const variationIds = variations.map(v => v.id);

    const result = await this.inventoryRepo
      .createQueryBuilder()
      .delete()
      .from(Inventory)
      .where('productVariationId IN (:...ids)', { ids: variationIds })
      .execute();

    this.logger.log(`🗑️ Eliminados ${result.affected} registros de inventario para el producto ${productId}.`);
  }

  // --- Metodos de Lectura (Frontend) ---

  async getStockByProduct(productId: number) {
    // Buscamos todas las variaciones de un producto
    const variations = await this.variationRepo.find({
      where: { productId },
      relations: ['product'], // Opcional, si necesitas datos del padre
    });

    if (!variations.length) {
      return { productId, totalStock: 0, breakdown: [], message: 'No variations found' };
    }

    const variationIds = variations.map((v) => v.id);

    // Buscamos el stock de esas variaciones
    const stockItems = await this.inventoryRepo
      .createQueryBuilder('inventory')
      .where('inventory.productVariationId IN (:...ids)', { ids: variationIds })
      .getMany();

    const totalStock = stockItems.reduce((acc, item) => acc + item.quantity, 0);

    return {
      productId,
      totalStock,
      breakdown: stockItems,
    };
  }
}
```

## src/api/product/controllers/product.controller.ts

```typescript
/* eslint-disable prettier/prettier */
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { RoleIds } from '../../role/enum/role.enum';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { ProductService } from '../services/product.service';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { FindOneParams } from 'src/common/helper/findOneParams.dto';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { User } from 'src/database/entities/user.entity';

@Controller('product')
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Get(':id')
  async getProduct(@Param() product: FindOneParams) {
    return this.productService.getProduct(product.id);
  }
 @Get()
  async getAllProducts() {
  const products = await this.productService.getAllProducts();
  return {
    message: 'Productos recuperados exitosamente',
    data: products,
  };
}
  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post('create')
  async createProduct(
    @Body() body: CreateProductDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.createProduct(body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/details')
  async addProductDetails(
    @Param() product: FindOneParams,
    @Body() body: ProductDetailsDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.addProductDetails(product.id, body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/activate')
  async activateProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.activateProduct(product.id, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Delete(':id')
  async deleteProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.deleteProduct(product.id, user.id);
  }
}
```

## src/api/product/dto/product.dto.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsIn,
  IsNotEmpty,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import { variationTypesKeys } from 'src/database/entities/product.entity';
import { ProductDetails, ProductDetailsTypeFn } from './productDetails';

export class CreateProductDto {
  @IsNumber()
  @IsNotEmpty()
  public categoryId: number;
}

export class ProductDetailsDto {
  @IsString()
  @IsNotEmpty()
  public title: string;

  @IsString()
  @IsNotEmpty()
  public code: string;

  @IsDefined()
  @IsString()
  @IsIn(variationTypesKeys)
  public variationType: string;

  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: ProductDetails;

  @ArrayMinSize(1)
  @IsString({ each: true })
  public about: string[];

  @IsString()
  @IsNotEmpty()
  public description: string;
}
```

## src/api/product/dto/productDetails/computer.details.ts

```typescript
import { IsIn, IsNotEmpty, IsNumber, IsString } from 'class-validator';
import { Categories } from 'src/database/entities/category.entity';

export class ComputerDetails {
  @IsString()
  @IsNotEmpty()
  category = Categories.Computers;

  @IsNumber()
  capacity: number;

  @IsString()
  @IsIn(['GB', 'TB'])
  capacityUnit: 'GB' | 'TB';

  @IsString()
  @IsIn(['SSD', 'HD'])
  capacityType: 'SSD' | 'HD';

  @IsString()
  @IsNotEmpty()
  brand: string;

  @IsString()
  @IsNotEmpty()
  series: string;
}
```

## src/api/product/dto/productDetails/index.ts

```typescript
import { BadRequestException } from '@nestjs/common';
import { TypeHelpOptions } from 'class-transformer';
import { Categories } from 'src/database/entities/category.entity';
import { ComputerDetails } from './computer.details';
import { TestDetails } from './test.details';

export type ProductDetails = ComputerDetails | TestDetails;

export function ProductDetailsTypeFn(options: TypeHelpOptions) {
  switch (options.object?.details?.category) {
    case Categories.Computers:
      return ComputerDetails;
    case 'Test':
      return TestDetails;
  }

  throw new BadRequestException('invalid details.category input');
}
```

## src/api/product/dto/productDetails/test.details.ts

```typescript
export class TestDetails {
  category = 'Test';
  test: boolean;
}
```

## src/api/product/product.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ProductService } from './services/product.service';
import { ProductController } from './controllers/product.controller';
import { Category } from '../../database/entities/category.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { Product } from 'src/database/entities/product.entity';
import { BullModule } from '@nestjs/bullmq'; 
@Module({
  imports: [TypeOrmModule.forFeature([User, Product, Category]), UserModule,
 // Registramos la cola donde vamos a publicar mensajes
    BullModule.registerQueue({
      name: 'catalog-queue',
    }),],
  controllers: [ProductController],
  providers: [ProductService],
})
export class ProductModule {}
```

## src/api/product/services/product.service.ts

```typescript
/* eslint-disable prettier/prettier */
import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { EntityManager } from 'typeorm';
import { InjectEntityManager } from '@nestjs/typeorm';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { Category } from '../../../database/entities/category.entity';
import { Product } from 'src/database/entities/product.entity';
import { errorMessages } from 'src/errors/custom';
import { validate } from 'class-validator';
import { successObject } from 'src/common/helper/success-response.interceptor';
import { InjectQueue } from '@nestjs/bullmq'; // <--- Importamos
import { Queue } from 'bullmq'; // <--- Importamos 

@Injectable()
export class ProductService {
  [x: string]: any;
  constructor(
    @InjectEntityManager()
    private readonly entityManager: EntityManager,
    // Inyectamos la cola definida en el modulo
    @InjectQueue('catalog-queue') private readonly catalogQueue: Queue,
  ) {}

  async getProduct(productId: number) {
    const product = await this.entityManager.findOne(Product, {
      where: {
        id: productId,
      },
    });

    if (!product) throw new NotFoundException(errorMessages.product.notFound);

    return product;
  }
async getAllProducts(): Promise<Product[]> {
  // Busca todos los productos que no estén eliminados lógicamente
  return await this.productRepository.find({
    where: { isActive: true },
    order: { createdAt: 'DESC' }
  });
}
 async createProduct(data: CreateProductDto, merchantId: number) {
    const category = await this.entityManager.findOne(Category, {
      where: { id: data.categoryId },
    });
    if (!category) throw new NotFoundException(errorMessages.category.notFound);

    const product = await this.entityManager.create(Product, {
      category,
      merchantId,
    });

    const savedProduct = await this.entityManager.save(product);

    // --- EVENTO 1: PRODUCTO CREADO ---
    // Publicamos el evento a Redis. Esto es asíncrono y desacoplado.
    await this.catalogQueue.add('product.created', {
      productId: savedProduct.id,
      merchantId: merchantId,
      sku: savedProduct.code // Si tuvieras SKU
    });
    // ---------------------------------

    return savedProduct;
  }
  async addProductDetails(
    productId: number,
    body: ProductDetailsDto,
    merchantId: number,
  ) {
    const result = await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({
        ...body,
      })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute();
    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);
    return await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({ ...body })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute().then(res => res.raw[0]);
  }
  async activateProduct(productId: number, merchantId: number) {
    if (!(await this.validate(productId)))
      throw new ConflictException(errorMessages.product.notFulfilled);

    return await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({ isActive: true })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id', 'isActive'])
      .execute().then(res => res.raw[0]);
  }

  async validate(productId: number) {
     const product = await this.entityManager.findOne(Product, { where: { id: productId } });
    if (!product) throw new NotFoundException(errorMessages.product.notFound);
    const errors = await validate(product);
    return errors.length === 0;
  }

  async deleteProduct(productId: number, merchantId: number) {
    const result = await this.entityManager
      .createQueryBuilder()
      .delete()
      .from(Product)
      .where('id = :productId', { productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .execute();

    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);

    // Si se borró con éxito, avisamos al inventario para que limpie
    await this.catalogQueue.add('product.deleted', {
      productId: productId,
    });
    // ------------------------------------

    return successObject;
  }
}
```

## src/api/role/controllers/role.controller.spec.ts

```typescript
import { ConfigModule } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { configuration } from 'src/config';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { AuthModule } from '../../auth/auth.module';
import { RoleController } from './role.controller';
import { Role } from '../../../database/entities/role.entity';
import { RoleIds, Roles } from '../enum/role.enum';
import { RoleService } from '../services/role.service';
import { UserService } from 'src/api/user/services/user.service';

describe('RoleController', () => {
  let controller: RoleController;
  let fakeRoleService: Partial<RoleService>;
  let fakeUserService: Partial<UserService>;

  const customerRole = {
    id: RoleIds.Customer,
    name: Roles.Customer,
  } as Role;

  beforeEach(async () => {
    fakeRoleService = {
      findById: () => {
        return Promise.resolve(customerRole);
      },
    };
    fakeUserService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [RoleController],
      providers: [
        {
          provide: RoleService,
          useValue: fakeRoleService,
        },
        {
          provide: UserService,
          useValue: fakeUserService,
        },
      ],
      imports: [
        AuthModule,
        ConfigModule.forRoot({ load: [configuration], isGlobal: true }),
        TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
      ],
    }).compile();

    controller = module.get<RoleController>(RoleController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/role/controllers/role.controller.ts

```typescript
import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { AssignRoleDto } from '../dto/role.dto';
import { RoleIds } from '../enum/role.enum';
import { RoleService } from '../services/role.service';

@Controller('role')
export class RoleController {
  constructor(private readonly roleService: RoleService) {}

  @Auth(RoleIds.Admin)
  @Post('assign')
  async assignRoleToUser(@Body() body: AssignRoleDto) {
    return this.roleService.assignRoleToUser(body);
  }
}
```

## src/api/role/dto/role.dto.ts

```typescript
import { IsNotEmpty, IsNumber } from 'class-validator';

export class AssignRoleDto {
  @IsNumber()
  @IsNotEmpty()
  public userId: number;

  @IsNumber()
  @IsNotEmpty()
  public roleId: number;
}
```

## src/api/role/enum/role.enum.ts

```typescript
export enum RoleIds {
  Customer = 1,
  Merchant,
  Admin,
}

export enum Roles {
  Customer = 'Customer',
  Merchant = 'Merchant',
  Admin = 'Admin',
}
```

## src/api/role/role.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Role } from '../../database/entities/role.entity';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { RoleController } from './controllers/role.controller';
import { RoleService } from './services/role.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [TypeOrmModule.forFeature([Role, User]), UserModule],
  controllers: [RoleController],
  providers: [RoleService, UserService],
  exports: [RoleService],
})
export class RoleModule {}
```

## src/api/role/services/role.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Role } from 'src/database/entities/role.entity';
import { AssignRoleDto } from '../dto/role.dto';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RoleService {
  constructor(
    @InjectRepository(Role) private readonly rolesRepository: Repository<Role>,
    private readonly userService: UserService,
  ) {}

  async assignRoleToUser(data: AssignRoleDto) {
    const role = await this.findById(data.roleId);
    const user = await this.userService.findById(data.userId, { roles: true });
    if (!user.roles.some((userRole) => userRole.id === data.roleId)) {
      user.roles.push(role);
    }
    return this.userService.save(user);
  }

  async findById(roleId: number) {
    const role = await this.rolesRepository.findOne({
      where: {
        id: roleId,
      },
    });
    if (!role) {
      throw new NotFoundException(errorMessages.role.notFound);
    }
    return role;
  }
}
```

## src/api/user/controllers/user.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { Serialize } from 'src/common/helper/serialize.interceptor';
import { User } from 'src/database/entities/user.entity';
import { UserDto } from '../dto/user.dto';
import { UserService } from '../services/user.service';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Auth()
  @Serialize(UserDto)
  @Get('profile')
  profile(@CurrentUser() user: User) {
    return this.userService.findById(user.id);
  }
}
```

## src/api/user/dto/user.dto.ts

```typescript
import { Expose } from 'class-transformer';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  public email: string;

  @IsString()
  @IsNotEmpty()
  public password: string;
}

export class UserDto {
  @Expose()
  public id: number;

  @Expose()
  public email: string;
}
```

## src/api/user/dto/user.types.ts

```typescript
export type UserRelation = {
  roles: boolean;
};
```

## src/api/user/services/user.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { Repository } from 'typeorm';
import { hash, compare } from 'bcrypt';
import { InjectRepository } from '@nestjs/typeorm';
import { User } from 'src/database/entities/user.entity';
import { CreateUserDto } from '../dto/user.dto';
import { Role } from 'src/database/entities/role.entity';
import { UserRelation } from '../dto/user.types';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User) private readonly repository: Repository<User>,
  ) {}

  public async createUser(
    body: CreateUserDto,
    ...roles: Role[]
  ): Promise<User> {
    body.password = await hash(body.password, 10);
    const user: User = this.repository.create({
      ...body,
      roles,
    });

    return this.repository.save(user);
  }

  public async findByEmail(
    email: string,
    relations?: UserRelation,
  ): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        email,
      },
      relations,
    });
    return user;
  }

  public async comparePassword(password, userPassword): Promise<boolean> {
    return compare(password, userPassword);
  }

  public async findById(id: number, relations?: UserRelation): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        id,
      },
      relations,
    });
    if (!user) {
      throw new NotFoundException(errorMessages.user.notFound);
    }
    return user;
  }

  public async save(user: User) {
    return this.repository.save(user);
  }
}
```

## src/api/user/user.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../../database/entities/user.entity';
import { UserController } from './controllers/user.controller';
import { UserService } from './services/user.service';

@Module({
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
  imports: [TypeOrmModule.forFeature([User])],
})
export class UserModule {}
```

## src/app.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
```

## src/app.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

## src/app.module.ts

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config'; // Asegúrate de importar ConfigService
import { TypeOrmModule } from '@nestjs/typeorm';
import { BullModule } from '@nestjs/bullmq';
import * as Joi from 'joi';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { TypeOrmConfigService } from './database/typeorm/typeorm.service';
import { ApiModule } from './api/api.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      validationSchema: Joi.object({
        NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),
        PORT: Joi.number().default(3000),
        DATABASE_HOST: Joi.string().required(),
        DATABASE_PORT: Joi.number().default(5432),
        DATABASE_USER: Joi.string().required(),
        DATABASE_PASSWORD: Joi.string().required(),
        DATABASE_NAME: Joi.string().required(),
        JWT_SECRET: Joi.string().required(),
        REDIS_HOST: Joi.string().default('127.0.0.1'),
        REDIS_PORT: Joi.number().default(6379),
      }),
    }),
    
    // Configuración BLINDADA de BullMQ
    BullModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const host = configService.get<string>('REDIS_HOST');
        const port = configService.get<number>('REDIS_PORT');
        
        console.log(`[BullMQ] Intentando conectar a Redis en: ${host}:${port}`);
        
        return {
          connection: {
            host: host,
            port: Number(port), // Forzamos que sea numero sí o sí
          },
        };
      },
      inject: [ConfigService],
    }),

    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    ApiModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

## src/app.service.ts

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
```

## src/common/helper/findOneParams.dto.ts

```typescript
import { IsNumberString } from 'class-validator';

export class FindOneParams {
  @IsNumberString()
  id: number;
}
```

## src/common/helper/serialize.interceptor.ts

```typescript
import {
  UseInterceptors,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { plainToInstance } from 'class-transformer';

interface ClassConstructor {
  new (...args: any[]): any;
}

export function Serialize(dto: ClassConstructor) {
  return UseInterceptors(new SerializeInterceptor(dto));
}

export class SerializeInterceptor implements NestInterceptor {
  constructor(private dto: any) {}

  intercept(context: ExecutionContext, handler: CallHandler): Observable<any> {
    return handler.handle().pipe(
      map((data: any) => {
        return plainToInstance(this.dto, data, {
          excludeExtraneousValues: true,
        });
      }),
    );
  }
}
```

## src/common/helper/success-response.interceptor.ts

```typescript
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { map, Observable } from 'rxjs';

@Injectable()
export class SucessResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        return {
          isSuccess: true,
          message: 'success',
          data,
          errorCode: null,
          errors: [],
        };
      }),
    );
  }
}

export const successObject = {
  message: 'success',
};
```

## src/database/entities/category.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  PrimaryColumn,
} from 'typeorm';
import { Product } from './product.entity';

@Entity()
export class Category {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar' })
  public name: string;

  @OneToMany(() => Product, (product) => product.category)
  products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CategoryIds {
  Computers = 1,
  Fashion,
}

export enum Categories {
  Computers = 'Computers',
  Fashion = 'Fashion',
}
```

## src/database/entities/color.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Color {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public name!: string;

  @Column({ type: 'varchar', length: 10 })
  public hexCode: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum Colors {
  NA = 'NA',
  Red = 'red',
  Green = 'green',
  Blue = 'blue',
}

export enum ColorsHexCodes {
  NA = 'NA',
  Red = '#FF0000',
  Green = '#00FF00',
  Blue = '#0000FF',
}
```

## src/database/entities/country.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Country {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CountryCodes {
  Egypt = 'EG',
}

export enum Countries {
  Egypt = 'Egypt',
}
```

## src/database/entities/currency.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Currency {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CurrencyCodes {
  EGP = 'EGP',
}

export enum CurrencyNames {
  EGP = 'Egyptian Pound',
}
```

## src/database/entities/inventory.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class Inventory {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @Column({ type: 'int' })
  public quantity: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/product.entity.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import {
  ProductDetails,
  ProductDetailsTypeFn,
} from 'src/api/product/dto/productDetails';
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  JoinColumn,
  Index,
} from 'typeorm';
import { Category } from './category.entity';
import { User } from './user.entity';

@Entity()
export class Product {
  @PrimaryGeneratedColumn()
  @IsDefined()
  @IsNumber()
  public id!: number;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  @Index()
  public code: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public title: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public variationType: string;

  @Column({ type: 'text', nullable: true })
  @IsDefined()
  @IsString()
  public description?: string | null;

  @Column({ type: 'text', array: true, default: [] })
  @ArrayMinSize(1)
  @IsString({ each: true })
  public about?: string[];

  @Column({ type: 'jsonb', nullable: true })
  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: Partial<ProductDetails> | null;

  @Column({ default: false })
  public isActive: boolean;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public merchantId: number;

  @ManyToOne(() => User, (user) => user.products)
  @JoinColumn({ name: 'merchantId' })
  public merchant: User;

  @ManyToOne(() => Category, (category) => category.products)
  @JoinColumn({ name: 'categoryId' })
  public category: Category;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public categoryId: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum VariationTypes {
  NONE = 'NONE',
  OnlySize = 'OnlySize',
  OnlyColor = 'OnlyColor',
  SizeAndColor = 'SizeAndColor',
}
export const variationTypesKeys = Object.keys(VariationTypes);
```

## src/database/entities/productVariation.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Color } from './color.entity';
import { Product } from './product.entity';
import { Size } from './size.entity';

@Entity()
export class ProductVariation {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => Product)
  @JoinColumn({ name: 'productId' })
  public product: Product;

  @Column({ type: 'int' })
  public productId: number;

  @ManyToOne(() => Size)
  @JoinColumn({ name: 'sizeCode' })
  public size: Size;

  @Column({ type: 'varchar', length: 7 })
  public sizeCode: string;

  @ManyToOne(() => Color)
  @JoinColumn({ name: 'colorName' })
  public color: Color;

  @Column({ type: 'varchar', length: 30 })
  public colorName: string;

  @Column({ type: 'text', array: true, default: [] })
  public imageUrls: string[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/productVariation_price.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { Currency } from './currency.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class ProductVariationPrice {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @ManyToOne(() => Currency)
  @JoinColumn({ name: 'currencyCode' })
  public currency: Currency;

  @Column({ type: 'varchar', length: 7 })
  public currencyCode: string;

  @Column({ type: 'float' })
  public price: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/role.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
  ManyToMany,
} from 'typeorm';
import { User } from './user.entity';

@Entity()
export class Role {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public name: string;

  @ManyToMany(() => User, (user) => user.roles)
  public users: User[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/size.entity.ts

```typescript
import {
  Entity,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Size {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public code!: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum SizeCodes {
  NA = 'NA',
  Small = 'S',
  Medium = 'M',
  Large = 'L',
  XLarge = 'XL',
  XXLarge = 'XXL',
}
```

## src/database/entities/user.entity.ts

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToMany,
  JoinTable,
  OneToMany,
} from 'typeorm';
import { Product } from './product.entity';
import { Role } from './role.entity';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public email: string;

  @Column({ type: 'varchar' })
  public password: string;

  @ManyToMany(() => Role, (role) => role.users)
  @JoinTable({ name: 'user_roles' })
  public roles: Role[];

  @OneToMany(() => Product, (product) => product.merchant)
  public products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/migration/datasource.ts

```typescript
import { DataSource } from 'typeorm';
import { dataSourceOptions } from '../typeorm/typeOrm.config';

const datasource = new DataSource(dataSourceOptions);

export default datasource;
```

## src/database/seed/seed.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Category } from 'src/database/entities/category.entity';
import { Role } from 'src/database/entities/role.entity';
import { User } from 'src/database/entities/user.entity';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { Color } from '../entities/color.entity';
import { Country } from '../entities/country.entity';
import { Currency } from '../entities/currency.entity';
import { Size } from '../entities/size.entity';
import { SeedService } from './seed.service';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';
//  La importación 'configuration' ha sido eliminada

@Module({
  imports: [
    // Agregamos ConfigModule para que lea el .env al ejecutar seeds
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    TypeOrmModule.forFeature([
      Role,
      User,
      Category,
      Size,
      Color,
      Country,
      Currency,
    ]),
  ],
  controllers: [],
  providers: [
    SeedService,
    RolesSeeder,
    AdminSeeder,
    CategorySeeder,
    SizeSeeder,
    ColorSeeder,
    CountrySeeder,
    CurrencySeeder,
  ],
})
export class SeedModule {}
```

## src/database/seed/seed.service.ts

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Promise as Bluebird } from 'bluebird';
import { SeederInterface } from './seeder.interface';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';

@Injectable()
export class SeedService {
  private readonly seeders: SeederInterface[] = [];
  private readonly logger = new Logger(SeedService.name);

  constructor(
    rolesSeeder: RolesSeeder,
    adminSeeder: AdminSeeder,
    categoriesSeeder: CategorySeeder,
    sizesSeeder: SizeSeeder,
    colorsSeeder: ColorSeeder,
    countrySeeder: CountrySeeder,
    currencySeeder: CurrencySeeder,
  ) {
    this.seeders = [
      rolesSeeder,
      adminSeeder,
      categoriesSeeder,
      sizesSeeder,
      colorsSeeder,
      countrySeeder,
      currencySeeder,
    ];
  }

  async seed() {
    await Bluebird.each(this.seeders, async (seeder: SeederInterface) => {
      this.logger.log(`Seeding ${seeder.constructor.name}`);
      await seeder.seed();
    });
  }
}
```

## src/database/seed/seed.ts

```typescript
import { NestFactory } from '@nestjs/core';
import { SeedModule } from './seed.module';
import { SeedService } from './seed.service';

async function bootstrap() {
  const app = await NestFactory.create(SeedModule);
  const seedService = app.get(SeedService);
  await seedService.seed();
  await app.close();
}
bootstrap();
```

## src/database/seed/seeder.interface.ts

```typescript
export interface SeederInterface {
  seed(): Promise<void>;
}
```

## src/database/seed/seeders/category.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Categories,
  Category,
  CategoryIds,
} from 'src/database/entities/category.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CategorySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Category)
    private readonly categoriesRepository: Repository<Category>,
  ) {}

  async seed() {
    const data: Partial<Category>[] = this.generateData();
    await this.categoriesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Category>[] {
    const data: Partial<Category>[] = [];
    Object.keys(Categories).forEach((key) => {
      data.push({
        id: CategoryIds[key],
        name: Categories[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/color.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Color,
  Colors,
  ColorsHexCodes,
} from 'src/database/entities/color.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class ColorSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Color)
    private readonly colorsRepository: Repository<Color>,
  ) {}

  async seed() {
    const data: Partial<Color>[] = this.generateData();
    await this.colorsRepository.upsert(data, {
      conflictPaths: ['name'],
    });
  }

  generateData(): Partial<Color>[] {
    const data: Partial<Color>[] = [];
    Object.keys(Colors).forEach((key) => {
      data.push({
        name: Colors[key],
        hexCode: ColorsHexCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/country.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Countries,
  Country,
  CountryCodes,
} from 'src/database/entities/country.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CountrySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Country)
    private readonly countryRepository: Repository<Country>,
  ) {}

  async seed() {
    const data: Partial<Country>[] = this.generateData();
    await this.countryRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Country>[] {
    const data: Partial<Country>[] = [];
    Object.keys(Countries).forEach((key) => {
      data.push({
        code: CountryCodes[key],
        name: Countries[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/currency.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Currency,
  CurrencyCodes,
  CurrencyNames,
} from 'src/database/entities/currency.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CurrencySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Currency)
    private readonly currencyRepository: Repository<Currency>,
  ) {}

  async seed() {
    const data: Partial<Currency>[] = this.generateData();
    await this.currencyRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Currency>[] {
    const data: Partial<Currency>[] = [];
    Object.keys(CurrencyCodes).forEach((key) => {
      data.push({
        code: CurrencyCodes[key],
        name: CurrencyNames[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/role.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';
import { Role } from 'src/database/entities/role.entity';
import { RoleIds, Roles } from 'src/api/role/enum/role.enum';

@Injectable()
export class RolesSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Role)
    private readonly rolesRepository: Repository<Role>,
  ) {}

  async seed() {
    const data: Partial<Role>[] = this.generateData();
    await this.rolesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Role>[] {
    const data: Partial<Role>[] = [];
    Object.keys(Roles).forEach((key) => {
      data.push({
        id: RoleIds[key],
        name: Roles[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/size.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Size, SizeCodes } from 'src/database/entities/size.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class SizeSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Size)
    private readonly SizeRepository: Repository<Size>,
  ) {}

  async seed() {
    const data: Partial<Size>[] = this.generateData();
    await this.SizeRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Size>[] {
    const data: Partial<Size>[] = [];
    Object.keys(SizeCodes).forEach((key) => {
      data.push({
        code: SizeCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/typeorm/typeOrm.config.ts

```typescript
/* eslint-disable prettier/prettier */
import { DataSource, DataSourceOptions } from 'typeorm';
import { config } from 'dotenv';

// Carga .env solo si estamos en local y no en producción (donde ya existen las vars)
if (process.env.NODE_ENV !== 'production') {
  config(); 
}

export const dataSourceOptions: DataSourceOptions = {
  type: 'postgres',
  host: process.env.DATABASE_HOST,
  port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
  database: process.env.DATABASE_NAME,
  username: process.env.DATABASE_USER,
  password: process.env.DATABASE_PASSWORD,
  entities: ['dist/**/*.entity.js'], // Apuntamos a dist para producción
  migrations: ['dist/database/migration/history/*.js'],
  synchronize: false, 
  logging: process.env.NODE_ENV === 'development',
};

// Default export para CLI de TypeORM
const datasource = new DataSource(dataSourceOptions);
export default datasource;
```

## src/database/typeorm/typeorm.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import { TypeOrmOptionsFactory, TypeOrmModuleOptions } from '@nestjs/typeorm';
import { dataSourceOptions } from 'src/database/typeorm/typeOrm.config';

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  public createTypeOrmOptions(): TypeOrmModuleOptions {
    return dataSourceOptions;
  }
}
```

## src/errors/custom/index.ts

```typescript
export interface ErrorBody extends Error {
  code: string;
}
//corrijo errores de texto wronCredentials por wrongCredentials
//invlidToken por invalidToken
export const errorMessages = {
  auth: {
    wrongCredentials: {
      message: 'wrong data provided',
      code: '60001',
    },
    userAlreadyExist: {
      message: 'user already exist',
      code: '60002',
    },
    expiredToken: {
      message: 'token expired',
      code: '60003',
    },
    invalidToken: {
      message: 'invalid token',
      code: '60004',
    },
    notAllowed: {
      message: 'not allowed',
      code: '60005',
    },
  },
  user: {
    notFound: {
      message: 'user not found',
      code: '60101',
    },
  },
  role: {
    notFound: {
      message: 'role not found',
      code: '60201',
    },
  },
  category: {
    notFound: {
      message: 'category not found',
      code: '60301',
    },
  },
  product: {
    notFound: {
      message: 'product not found',
      code: '60401',
    },
    notFulfilled: {
      message: 'not all product info is fulfilled',
      code: '60402',
    },
  },
  global: {
    internalError: {
      message: 'something went wrong',
      code: '70000',
    },
  },
};
```

## src/errors/errors.filter.ts

```typescript
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';
import { ErrorBody, errorMessages } from './custom';

@Catch()
export class ErrorsFilter implements ExceptionFilter {
  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

  catch(exception: Error, host: ArgumentsHost): void {
    Logger.error(exception.message);
    const { httpAdapter } = this.httpAdapterHost;

    const ctx = host.switchToHttp();
    if (exception instanceof HttpException) {
      const message = exception.message;
      const httpStatus =
        exception.getStatus() || HttpStatus.INTERNAL_SERVER_ERROR;
      const errorMessage = (exception.getResponse() as HttpException).message;
      const errorCode = (exception.getResponse() as ErrorBody).code || '60400';
      const errors = Array.isArray(errorMessage)
        ? errorMessage
        : [errorMessage];
      const responseBody = {
        isSuccess: false,
        message,
        errorCode,
        data: null,
        errors,
      };

      httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);
    } else {
      const responseBody = {
        isSuccess: false,
        message: errorMessages.global.internalError.message,
        errorCode: errorMessages.global.internalError.code,
        data: null,
        errors: [errorMessages.global.internalError.message],
      };

      httpAdapter.reply(
        ctx.getResponse(),
        responseBody,
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
```

## src/main.ts

```typescript
/* eslint-disable prettier/prettier */
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // 1. Habilitar CORS (Justificación: Permite que el Front en localhost:5173 acceda a la API)
  app.enableCors({
    origin: 'http://localhost:5173', // URL por defecto de Vite
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  });

  // 2. Global Prefix (Opcional pero recomendado para Sr.)
  app.setGlobalPrefix('api');

  // 3. Pipes de Validación
  app.useGlobalPipes(new ValidationPipe({ 
    transform: true,
    whitelist: true, // Ignora propiedades que no esten en el DTO
    forbidNonWhitelisted: true, // Lanza error si envían datos de mas
  }));

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}

bootstrap();
```

## Statistics

- Total Files: 72
- Total Characters: 382240
- Total Tokens: 0
`````````

## src/api/api.module.ts

```typescript
import { Module } from '@nestjs/common';
import { APP_FILTER, APP_INTERCEPTOR } from '@nestjs/core';
import { SucessResponseInterceptor } from 'src/common/helper/success-response.interceptor';
import { AuthModule } from './auth/auth.module';
import { UserModule } from './user/user.module';
import { RoleModule } from './role/role.module';
import { ProductModule } from './product/product.module';
import { ErrorsFilter } from 'src/errors/errors.filter';
import { InventoryModule } from './inventory/inventory.module';

@Module({
  imports: [AuthModule, UserModule, RoleModule, ProductModule, InventoryModule],
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: SucessResponseInterceptor,
    },
    {
      provide: APP_FILTER,
      useClass: ErrorsFilter,
    },
  ],
})
export class ApiModule {}
```

## src/api/auth/auth.module.ts

```typescript
import { Module } from '@nestjs/common';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { RoleModule } from '../role/role.module';
import { AuthController } from './controllers/auth.controller';
import { AuthService } from './services/auth.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [
    UserModule,
    TypeOrmModule.forFeature([User]),
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '3h' },
    }),
    RoleModule,
  ],
  controllers: [AuthController],
  providers: [AuthService, UserService],
  exports: [],
})
export class AuthModule {}
```

## src/api/auth/controllers/auth.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from '../services/auth.service';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;
  let fakeAuthService: Partial<AuthService>;

  beforeEach(async () => {
    fakeAuthService = {
      register: () => {
        return Promise.resolve({
          message: 'success',
        });
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: fakeAuthService,
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/auth/controllers/auth.controller.ts

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { CreateUserDto } from 'src/api/user/dto/user.dto';
import { AuthService } from '../services/auth.service';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  login(@Body() user: CreateUserDto) {
    return this.authService.login(user);
  }

  @Post('register')
  register(@Body() user: CreateUserDto) {
    return this.authService.register(user);
  }
}
```

## src/api/auth/dto/auth.dto.ts

```typescript
import { IsNotEmpty } from 'class-validator';

export class PayloadDto {
  @IsNotEmpty()
  public email: string;

  @IsNotEmpty()
  public id: number;
}
```

## src/api/auth/guards/auth.decorator.ts

```typescript
import { applyDecorators, SetMetadata, UseGuards } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { RolesGuard } from './roles.guard';

export function Auth(...roleIds: number[]) {
  return applyDecorators(
    SetMetadata('roleIds', roleIds),
    UseGuards(AuthGuard, RolesGuard),
  );
}
```

## src/api/auth/guards/roles.guard.ts

```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private readonly userService: UserService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const roles = this.reflector.get<number[]>('roleIds', context.getHandler());
    if (roles.length === 0) return true;
    const request = context.switchToHttp().getRequest();
    if (!request.user.roles.some((userRole) => roles.includes(userRole.id)))
      throw new UnauthorizedException(errorMessages.auth.notAllowed);

    return true;
  }
}
```

## src/api/auth/guards/user.decorator.ts

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from 'src/database/entities/user.entity';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext): User => {
    const req = context.switchToHttp().getRequest();
    return req.user;
  },
);
```

## src/api/inventory/controllers/inventory.controller.ts

```typescript
/* eslint-disable prettier/prettier */
import { Controller, Get, Param, ParseIntPipe } from '@nestjs/common';
import { InventoryService } from '../services/inventory.service';
//import { Auth } from 'src/api/auth/guards/auth.decorator';
// Importamos Auth para proteger la ruta, aunque sea de lectura (opcional según regla de negocio)

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @Get('product/:id')
  async getProductStock(@Param('id', ParseIntPipe) productId: number) {
    return this.inventoryService.getStockByProduct(productId);
  }
  @Get()
async getAllInventory() {
  const inventory = await this.inventoryService.getAllInventory();
  return {
    message: 'Inventario recuperado exitosamente',
    data: inventory,
  };
}
}
```

## src/api/inventory/inventory.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';
import { InventoryController } from './controllers/inventory.controller';
import { InventoryService } from './services/inventory.service';
import { InventoryProcessor } from './inventory.processor'; // <--- Importamos

@Module({
  imports: [
    TypeOrmModule.forFeature([Inventory, ProductVariation]),
  ],
  controllers: [InventoryController],
  providers: [InventoryService, 
    InventoryProcessor // Registramos el processor como provider (importante )

  ],
  exports: [InventoryService], // Exportamos el servicio para usarlo en otros lados si hiciera falta
})
export class InventoryModule {}
```

## src/api/inventory/inventory.processor.ts

```typescript
/* eslint-disable prettier/prettier */
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { Logger } from '@nestjs/common';
import { InventoryService } from './services/inventory.service';

@Processor('catalog-queue')
export class InventoryProcessor extends WorkerHost {
  private readonly logger = new Logger(InventoryProcessor.name);

  constructor(private readonly inventoryService: InventoryService) {
    super();
  }

  async process(job: Job<any, any, string>): Promise<any> {
    this.logger.log(`⚡ Evento recibido: ${job.name} | JobId: ${job.id}`);

    switch (job.name) {
      case 'product.created':
        return this.handleProductCreated(job);
      case 'product.deleted':
        return this.handleProductDeleted(job);
      default:
        this.logger.warn(`Evento desconocido ignorado: ${job.name}`);
    }
  }

  // Manejo del Evento 1
  private async handleProductCreated(job: Job) {
    const { productId } = job.data;
    this.logger.log(`📦 Creando inventario inicial para Producto ID: ${productId}...`);
    
    try {
      // Aquí simulamos la creación. En un caso real, ProductService debería enviar 
      // el ID de la "Variación" (Talla/Color), no solo del Producto padre.
      // Como el challenge pide "base razonable", asumiremos que creamos stock 
      // para una variación placeholder o manejamos la lógica aquí.
      
      // Llamada al servicio de inventario (que implementaremos abajo)
      await this.inventoryService.createInitialStock(productId);
      
      this.logger.log(`✅ Inventario creado exitosamente para Producto ID: ${productId}`);
    } catch (error) {
      this.logger.error(`❌ Error creando inventario: ${error.message}`);
      // BullMQ reintentará esto automáticamente si fallamos aquí
      throw error; 
    }
  }

  // Manejo del Evento 2
  private async handleProductDeleted(job: Job) {
    const { productId } = job.data;
    this.logger.warn(`🗑️ Producto ${productId} eliminado. Limpiando stock asociado...`);
    
    // Aquí llamaríamos a un método de servicio para borrar/archivar
    // await this.inventoryService.removeStockForProduct(productId);
    
    // Simulamos un delay para ver la asincronía
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    this.logger.log(`✅ Stock del producto ${productId} eliminado correctamente.`);
  }
}
```

## src/api/inventory/services/inventory.service.ts

```typescript
/* eslint-disable prettier/prettier */
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Inventory } from 'src/database/entities/inventory.entity';
import { ProductVariation } from 'src/database/entities/productVariation.entity';

@Injectable()
export class InventoryService {
  private readonly logger = new Logger(InventoryService.name);

  constructor(
    @InjectRepository(Inventory)
    private readonly inventoryRepo: Repository<Inventory>,
    @InjectRepository(ProductVariation)
    private readonly variationRepo: Repository<ProductVariation>,
  ) {}
  
  /**
   * Maneja el evento 'product.created'.
   * Intenta inicializar stock si existen variaciones, o simula la accion.
   */
  async getAllInventory(): Promise<Inventory[]> {
  // Retorna todos los registros de inventario
  return await this.inventoryRepo.find({
    order: { updatedAt: 'DESC' }
  });
}
  async createInitialStock(productId: number) {
    // 1. Buscamos si el producto ya tiene variaciones (ej. si se crearon en la misma transaccion)
    const variations = await this.variationRepo.find({
      where: { productId },
    });

    const countryCode = 'EG'; // Hardcodeado por reglas de negocio actuales

    // CASO A: El producto se creo pero aon no tiene Talla/Color definido.
    if (variations.length === 0) {
      this.logger.log(
        `[LOGIC] El producto ID ${productId} no tiene variaciones aún. No se puede crear registro en tabla 'Inventory' por restricción de FK.`,
      );
      this.logger.log(`[SIMULATION] Se reserva espacio lógico de inventario para Producto ${productId}.`);
      return;
    }
    
    // CASO B: (Edge Case) El producto ya tiene variaciones, creamos stock en 0 para cada una.
    const inventoryEntities = variations.map((variation) => {
      return this.inventoryRepo.create({
        productVariationId: variation.id,
        countryCode: countryCode,
        quantity: 0, // Stock inicial por defecto
      });
    });

    await this.inventoryRepo.save(inventoryEntities);
    this.logger.log(`✅ Stock inicial (0) creado para ${variations.length} variaciones del producto ${productId}.`);
  }

  /*
    Maneja el evento 'product.deleted'.
    Elimina todo registro de inventario asociado a las variaciones de ese producto.
   */
  async deleteStockForProduct(productId: number) {
    // Usamos QueryBuilder para hacer un DELETE con Subquery, es mas eficiente que buscar y borrar uno por uno.
    // SQL Equivalente: DELETE FROM inventory WHERE productVariationId IN (SELECT id FROM product_variation WHERE productId = X)
    
    const variations = await this.variationRepo.find({ where: { productId }, select: ['id'] });
    
    if (variations.length === 0) {
        this.logger.log(`No hay stock que limpiar para el producto ${productId}`);
        return;
    }

    const variationIds = variations.map(v => v.id);

    const result = await this.inventoryRepo
      .createQueryBuilder()
      .delete()
      .from(Inventory)
      .where('productVariationId IN (:...ids)', { ids: variationIds })
      .execute();

    this.logger.log(`🗑️ Eliminados ${result.affected} registros de inventario para el producto ${productId}.`);
  }

  // --- Metodos de Lectura (Frontend) ---

  async getStockByProduct(productId: number) {
    // Buscamos todas las variaciones de un producto
    const variations = await this.variationRepo.find({
      where: { productId },
      relations: ['product'], // Opcional, si necesitas datos del padre
    });

    if (!variations.length) {
      return { productId, totalStock: 0, breakdown: [], message: 'No variations found' };
    }

    const variationIds = variations.map((v) => v.id);

    // Buscamos el stock de esas variaciones
    const stockItems = await this.inventoryRepo
      .createQueryBuilder('inventory')
      .where('inventory.productVariationId IN (:...ids)', { ids: variationIds })
      .getMany();

    const totalStock = stockItems.reduce((acc, item) => acc + item.quantity, 0);

    return {
      productId,
      totalStock,
      breakdown: stockItems,
    };
  }
}
```

## src/api/product/controllers/product.controller.ts

```typescript
/* eslint-disable prettier/prettier */
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { RoleIds } from '../../role/enum/role.enum';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { ProductService } from '../services/product.service';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { FindOneParams } from 'src/common/helper/findOneParams.dto';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { User } from 'src/database/entities/user.entity';

@Controller('product')
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Get(':id')
  async getProduct(@Param() product: FindOneParams) {
    return this.productService.getProduct(product.id);
  }
 @Get()
  async getAllProducts() {
  const products = await this.productService.getAllProducts();
  return {
    message: 'Productos recuperados exitosamente',
    data: products,
  };
}
  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post('create')
  async createProduct(
    @Body() body: CreateProductDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.createProduct(body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/details')
  async addProductDetails(
    @Param() product: FindOneParams,
    @Body() body: ProductDetailsDto,
    @CurrentUser() user: User,
  ) {
    return this.productService.addProductDetails(product.id, body, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Post(':id/activate')
  async activateProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.activateProduct(product.id, user.id);
  }

  @Auth(RoleIds.Admin, RoleIds.Merchant)
  @Delete(':id')
  async deleteProduct(
    @Param() product: FindOneParams,
    @CurrentUser() user: User,
  ) {
    return this.productService.deleteProduct(product.id, user.id);
  }
}
```

## src/api/product/dto/product.dto.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsIn,
  IsNotEmpty,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import { variationTypesKeys } from 'src/database/entities/product.entity';
import { ProductDetails, ProductDetailsTypeFn } from './productDetails';

export class CreateProductDto {
  @IsNumber()
  @IsNotEmpty()
  public categoryId: number;
}

export class ProductDetailsDto {
  @IsString()
  @IsNotEmpty()
  public title: string;

  @IsString()
  @IsNotEmpty()
  public code: string;

  @IsDefined()
  @IsString()
  @IsIn(variationTypesKeys)
  public variationType: string;

  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: ProductDetails;

  @ArrayMinSize(1)
  @IsString({ each: true })
  public about: string[];

  @IsString()
  @IsNotEmpty()
  public description: string;
}
```

## src/api/product/dto/productDetails/computer.details.ts

```typescript
import { IsIn, IsNotEmpty, IsNumber, IsString } from 'class-validator';
import { Categories } from 'src/database/entities/category.entity';

export class ComputerDetails {
  @IsString()
  @IsNotEmpty()
  category = Categories.Computers;

  @IsNumber()
  capacity: number;

  @IsString()
  @IsIn(['GB', 'TB'])
  capacityUnit: 'GB' | 'TB';

  @IsString()
  @IsIn(['SSD', 'HD'])
  capacityType: 'SSD' | 'HD';

  @IsString()
  @IsNotEmpty()
  brand: string;

  @IsString()
  @IsNotEmpty()
  series: string;
}
```

## src/api/product/dto/productDetails/index.ts

```typescript
import { BadRequestException } from '@nestjs/common';
import { TypeHelpOptions } from 'class-transformer';
import { Categories } from 'src/database/entities/category.entity';
import { ComputerDetails } from './computer.details';
import { TestDetails } from './test.details';

export type ProductDetails = ComputerDetails | TestDetails;

export function ProductDetailsTypeFn(options: TypeHelpOptions) {
  switch (options.object?.details?.category) {
    case Categories.Computers:
      return ComputerDetails;
    case 'Test':
      return TestDetails;
  }

  throw new BadRequestException('invalid details.category input');
}
```

## src/api/product/dto/productDetails/test.details.ts

```typescript
export class TestDetails {
  category = 'Test';
  test: boolean;
}
```

## src/api/product/product.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ProductService } from './services/product.service';
import { ProductController } from './controllers/product.controller';
import { Category } from '../../database/entities/category.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { Product } from 'src/database/entities/product.entity';
import { BullModule } from '@nestjs/bullmq'; 
@Module({
  imports: [TypeOrmModule.forFeature([User, Product, Category]), UserModule,
 // Registramos la cola donde vamos a publicar mensajes
    BullModule.registerQueue({
      name: 'catalog-queue',
    }),],
  controllers: [ProductController],
  providers: [ProductService],
})
export class ProductModule {}
```

## src/api/product/services/product.service.ts

```typescript
/* eslint-disable prettier/prettier */
import {
  ConflictException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { EntityManager } from 'typeorm';
import { InjectEntityManager } from '@nestjs/typeorm';
import { CreateProductDto, ProductDetailsDto } from '../dto/product.dto';
import { Category } from '../../../database/entities/category.entity';
import { Product } from 'src/database/entities/product.entity';
import { errorMessages } from 'src/errors/custom';
import { validate } from 'class-validator';
import { successObject } from 'src/common/helper/success-response.interceptor';
import { InjectQueue } from '@nestjs/bullmq'; // <--- Importamos
import { Queue } from 'bullmq'; // <--- Importamos 

@Injectable()
export class ProductService {
  [x: string]: any;
  constructor(
    @InjectEntityManager()
    private readonly entityManager: EntityManager,
    // Inyectamos la cola definida en el modulo
    @InjectQueue('catalog-queue') private readonly catalogQueue: Queue,
  ) {}

  async getProduct(productId: number) {
    const product = await this.entityManager.findOne(Product, {
      where: {
        id: productId,
      },
    });

    if (!product) throw new NotFoundException(errorMessages.product.notFound);

    return product;
  }
async getAllProducts() {
  try {
    return await this.productRepository.find(); 
  } catch (error) {
    // Si esto falla, revisa que la tabla 'product' exista en PostgreSQL
    throw new Error('Error al consultar la base de datos');
  }
}
 async createProduct(data: CreateProductDto, merchantId: number) {
    const category = await this.entityManager.findOne(Category, {
      where: { id: data.categoryId },
    });
    if (!category) throw new NotFoundException(errorMessages.category.notFound);

    const product = await this.entityManager.create(Product, {
      category,
      merchantId,
    });

    const savedProduct = await this.entityManager.save(product);

    // --- EVENTO 1: PRODUCTO CREADO ---
    // Publicamos el evento a Redis. Esto es asíncrono y desacoplado.
    await this.catalogQueue.add('product.created', {
      productId: savedProduct.id,
      merchantId: merchantId,
      sku: savedProduct.code // Si tuvieras SKU
    });
    // ---------------------------------

    return savedProduct;
  }
  async addProductDetails(
    productId: number,
    body: ProductDetailsDto,
    merchantId: number,
  ) {
    const result = await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({
        ...body,
      })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute();
    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);
    return await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({ ...body })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id'])
      .execute().then(res => res.raw[0]);
  }
  async activateProduct(productId: number, merchantId: number) {
    if (!(await this.validate(productId)))
      throw new ConflictException(errorMessages.product.notFulfilled);

    return await this.entityManager
      .createQueryBuilder()
      .update<Product>(Product)
      .set({ isActive: true })
      .where('id = :id', { id: productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .returning(['id', 'isActive'])
      .execute().then(res => res.raw[0]);
  }

  async validate(productId: number) {
     const product = await this.entityManager.findOne(Product, { where: { id: productId } });
    if (!product) throw new NotFoundException(errorMessages.product.notFound);
    const errors = await validate(product);
    return errors.length === 0;
  }

  async deleteProduct(productId: number, merchantId: number) {
    const result = await this.entityManager
      .createQueryBuilder()
      .delete()
      .from(Product)
      .where('id = :productId', { productId })
      .andWhere('merchantId = :merchantId', { merchantId })
      .execute();

    if (result.affected < 1)
      throw new NotFoundException(errorMessages.product.notFound);

    // Si se borró con éxito, avisamos al inventario para que limpie
    await this.catalogQueue.add('product.deleted', {
      productId: productId,
    });
    // ------------------------------------

    return successObject;
  }
}
```

## src/api/role/controllers/role.controller.spec.ts

```typescript
import { ConfigModule } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { configuration } from 'src/config';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { AuthModule } from '../../auth/auth.module';
import { RoleController } from './role.controller';
import { Role } from '../../../database/entities/role.entity';
import { RoleIds, Roles } from '../enum/role.enum';
import { RoleService } from '../services/role.service';
import { UserService } from 'src/api/user/services/user.service';

describe('RoleController', () => {
  let controller: RoleController;
  let fakeRoleService: Partial<RoleService>;
  let fakeUserService: Partial<UserService>;

  const customerRole = {
    id: RoleIds.Customer,
    name: Roles.Customer,
  } as Role;

  beforeEach(async () => {
    fakeRoleService = {
      findById: () => {
        return Promise.resolve(customerRole);
      },
    };
    fakeUserService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [RoleController],
      providers: [
        {
          provide: RoleService,
          useValue: fakeRoleService,
        },
        {
          provide: UserService,
          useValue: fakeUserService,
        },
      ],
      imports: [
        AuthModule,
        ConfigModule.forRoot({ load: [configuration], isGlobal: true }),
        TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
      ],
    }).compile();

    controller = module.get<RoleController>(RoleController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
```

## src/api/role/controllers/role.controller.ts

```typescript
import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { AssignRoleDto } from '../dto/role.dto';
import { RoleIds } from '../enum/role.enum';
import { RoleService } from '../services/role.service';

@Controller('role')
export class RoleController {
  constructor(private readonly roleService: RoleService) {}

  @Auth(RoleIds.Admin)
  @Post('assign')
  async assignRoleToUser(@Body() body: AssignRoleDto) {
    return this.roleService.assignRoleToUser(body);
  }
}
```

## src/api/role/dto/role.dto.ts

```typescript
import { IsNotEmpty, IsNumber } from 'class-validator';

export class AssignRoleDto {
  @IsNumber()
  @IsNotEmpty()
  public userId: number;

  @IsNumber()
  @IsNotEmpty()
  public roleId: number;
}
```

## src/api/role/enum/role.enum.ts

```typescript
export enum RoleIds {
  Customer = 1,
  Merchant,
  Admin,
}

export enum Roles {
  Customer = 'Customer',
  Merchant = 'Merchant',
  Admin = 'Admin',
}
```

## src/api/role/role.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Role } from '../../database/entities/role.entity';
import { UserModule } from '../user/user.module';
import { User } from '../../database/entities/user.entity';
import { RoleController } from './controllers/role.controller';
import { RoleService } from './services/role.service';
import { UserService } from '../user/services/user.service';

@Module({
  imports: [TypeOrmModule.forFeature([Role, User]), UserModule],
  controllers: [RoleController],
  providers: [RoleService, UserService],
  exports: [RoleService],
})
export class RoleModule {}
```

## src/api/role/services/role.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Role } from 'src/database/entities/role.entity';
import { AssignRoleDto } from '../dto/role.dto';
import { UserService } from 'src/api/user/services/user.service';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class RoleService {
  constructor(
    @InjectRepository(Role) private readonly rolesRepository: Repository<Role>,
    private readonly userService: UserService,
  ) {}

  async assignRoleToUser(data: AssignRoleDto) {
    const role = await this.findById(data.roleId);
    const user = await this.userService.findById(data.userId, { roles: true });
    if (!user.roles.some((userRole) => userRole.id === data.roleId)) {
      user.roles.push(role);
    }
    return this.userService.save(user);
  }

  async findById(roleId: number) {
    const role = await this.rolesRepository.findOne({
      where: {
        id: roleId,
      },
    });
    if (!role) {
      throw new NotFoundException(errorMessages.role.notFound);
    }
    return role;
  }
}
```

## src/api/user/controllers/user.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { Auth } from 'src/api/auth/guards/auth.decorator';
import { CurrentUser } from 'src/api/auth/guards/user.decorator';
import { Serialize } from 'src/common/helper/serialize.interceptor';
import { User } from 'src/database/entities/user.entity';
import { UserDto } from '../dto/user.dto';
import { UserService } from '../services/user.service';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Auth()
  @Serialize(UserDto)
  @Get('profile')
  profile(@CurrentUser() user: User) {
    return this.userService.findById(user.id);
  }
}
```

## src/api/user/dto/user.dto.ts

```typescript
import { Expose } from 'class-transformer';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  public email: string;

  @IsString()
  @IsNotEmpty()
  public password: string;
}

export class UserDto {
  @Expose()
  public id: number;

  @Expose()
  public email: string;
}
```

## src/api/user/dto/user.types.ts

```typescript
export type UserRelation = {
  roles: boolean;
};
```

## src/api/user/services/user.service.ts

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { Repository } from 'typeorm';
import { hash, compare } from 'bcrypt';
import { InjectRepository } from '@nestjs/typeorm';
import { User } from 'src/database/entities/user.entity';
import { CreateUserDto } from '../dto/user.dto';
import { Role } from 'src/database/entities/role.entity';
import { UserRelation } from '../dto/user.types';
import { errorMessages } from 'src/errors/custom';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User) private readonly repository: Repository<User>,
  ) {}

  public async createUser(
    body: CreateUserDto,
    ...roles: Role[]
  ): Promise<User> {
    body.password = await hash(body.password, 10);
    const user: User = this.repository.create({
      ...body,
      roles,
    });

    return this.repository.save(user);
  }

  public async findByEmail(
    email: string,
    relations?: UserRelation,
  ): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        email,
      },
      relations,
    });
    return user;
  }

  public async comparePassword(password, userPassword): Promise<boolean> {
    return compare(password, userPassword);
  }

  public async findById(id: number, relations?: UserRelation): Promise<User> {
    const user: User = await this.repository.findOne({
      where: {
        id,
      },
      relations,
    });
    if (!user) {
      throw new NotFoundException(errorMessages.user.notFound);
    }
    return user;
  }

  public async save(user: User) {
    return this.repository.save(user);
  }
}
```

## src/api/user/user.module.ts

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../../database/entities/user.entity';
import { UserController } from './controllers/user.controller';
import { UserService } from './services/user.service';

@Module({
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
  imports: [TypeOrmModule.forFeature([User])],
})
export class UserModule {}
```

## src/app.controller.spec.ts

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
```

## src/app.controller.ts

```typescript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

## src/app.module.ts

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config'; // Asegúrate de importar ConfigService
import { TypeOrmModule } from '@nestjs/typeorm';
import { BullModule } from '@nestjs/bullmq';
import * as Joi from 'joi';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { TypeOrmConfigService } from './database/typeorm/typeorm.service';
import { ApiModule } from './api/api.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      validationSchema: Joi.object({
        NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),
        PORT: Joi.number().default(3000),
        DATABASE_HOST: Joi.string().required(),
        DATABASE_PORT: Joi.number().default(5432),
        DATABASE_USER: Joi.string().required(),
        DATABASE_PASSWORD: Joi.string().required(),
        DATABASE_NAME: Joi.string().required(),
        JWT_SECRET: Joi.string().required(),
        REDIS_HOST: Joi.string().default('127.0.0.1'),
        REDIS_PORT: Joi.number().default(6379),
      }),
    }),
    
    // Configuración BLINDADA de BullMQ
    BullModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const host = configService.get<string>('REDIS_HOST');
        const port = configService.get<number>('REDIS_PORT');
        
        console.log(`[BullMQ] Intentando conectar a Redis en: ${host}:${port}`);
        
        return {
          connection: {
            host: host,
            port: Number(port), // Forzamos que sea numero sí o sí
          },
        };
      },
      inject: [ConfigService],
    }),

    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    ApiModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

## src/app.service.ts

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
```

## src/common/helper/findOneParams.dto.ts

```typescript
import { IsNumberString } from 'class-validator';

export class FindOneParams {
  @IsNumberString()
  id: number;
}
```

## src/common/helper/serialize.interceptor.ts

```typescript
import {
  UseInterceptors,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { plainToInstance } from 'class-transformer';

interface ClassConstructor {
  new (...args: any[]): any;
}

export function Serialize(dto: ClassConstructor) {
  return UseInterceptors(new SerializeInterceptor(dto));
}

export class SerializeInterceptor implements NestInterceptor {
  constructor(private dto: any) {}

  intercept(context: ExecutionContext, handler: CallHandler): Observable<any> {
    return handler.handle().pipe(
      map((data: any) => {
        return plainToInstance(this.dto, data, {
          excludeExtraneousValues: true,
        });
      }),
    );
  }
}
```

## src/common/helper/success-response.interceptor.ts

```typescript
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { map, Observable } from 'rxjs';

@Injectable()
export class SucessResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        return {
          isSuccess: true,
          message: 'success',
          data,
          errorCode: null,
          errors: [],
        };
      }),
    );
  }
}

export const successObject = {
  message: 'success',
};
```

## src/database/entities/category.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  PrimaryColumn,
} from 'typeorm';
import { Product } from './product.entity';

@Entity()
export class Category {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar' })
  public name: string;

  @OneToMany(() => Product, (product) => product.category)
  products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CategoryIds {
  Computers = 1,
  Fashion,
}

export enum Categories {
  Computers = 'Computers',
  Fashion = 'Fashion',
}
```

## src/database/entities/color.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Color {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public name!: string;

  @Column({ type: 'varchar', length: 10 })
  public hexCode: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum Colors {
  NA = 'NA',
  Red = 'red',
  Green = 'green',
  Blue = 'blue',
}

export enum ColorsHexCodes {
  NA = 'NA',
  Red = '#FF0000',
  Green = '#00FF00',
  Blue = '#0000FF',
}
```

## src/database/entities/country.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Country {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CountryCodes {
  Egypt = 'EG',
}

export enum Countries {
  Egypt = 'Egypt',
}
```

## src/database/entities/currency.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Currency {
  @PrimaryColumn({ type: 'varchar', length: 7 })
  public code!: string;

  @Column({ type: 'varchar' })
  public name: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum CurrencyCodes {
  EGP = 'EGP',
}

export enum CurrencyNames {
  EGP = 'Egyptian Pound',
}
```

## src/database/entities/inventory.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class Inventory {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @Column({ type: 'int' })
  public quantity: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/product.entity.ts

```typescript
import { Type } from 'class-transformer';
import {
  ArrayMinSize,
  IsDefined,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import {
  ProductDetails,
  ProductDetailsTypeFn,
} from 'src/api/product/dto/productDetails';
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  JoinColumn,
  Index,
} from 'typeorm';
import { Category } from './category.entity';
import { User } from './user.entity';

@Entity()
export class Product {
  @PrimaryGeneratedColumn()
  @IsDefined()
  @IsNumber()
  public id!: number;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  @Index()
  public code: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public title: string;

  @Column({ type: 'varchar', nullable: true })
  @IsDefined()
  @IsString()
  public variationType: string;

  @Column({ type: 'text', nullable: true })
  @IsDefined()
  @IsString()
  public description?: string | null;

  @Column({ type: 'text', array: true, default: [] })
  @ArrayMinSize(1)
  @IsString({ each: true })
  public about?: string[];

  @Column({ type: 'jsonb', nullable: true })
  @IsDefined()
  @Type(ProductDetailsTypeFn)
  @ValidateNested()
  public details: Partial<ProductDetails> | null;

  @Column({ default: false })
  public isActive: boolean;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public merchantId: number;

  @ManyToOne(() => User, (user) => user.products)
  @JoinColumn({ name: 'merchantId' })
  public merchant: User;

  @ManyToOne(() => Category, (category) => category.products)
  @JoinColumn({ name: 'categoryId' })
  public category: Category;

  @Column({ type: 'int', nullable: true })
  @IsDefined()
  @IsNumber()
  public categoryId: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum VariationTypes {
  NONE = 'NONE',
  OnlySize = 'OnlySize',
  OnlyColor = 'OnlyColor',
  SizeAndColor = 'SizeAndColor',
}
export const variationTypesKeys = Object.keys(VariationTypes);
```

## src/database/entities/productVariation.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Color } from './color.entity';
import { Product } from './product.entity';
import { Size } from './size.entity';

@Entity()
export class ProductVariation {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => Product)
  @JoinColumn({ name: 'productId' })
  public product: Product;

  @Column({ type: 'int' })
  public productId: number;

  @ManyToOne(() => Size)
  @JoinColumn({ name: 'sizeCode' })
  public size: Size;

  @Column({ type: 'varchar', length: 7 })
  public sizeCode: string;

  @ManyToOne(() => Color)
  @JoinColumn({ name: 'colorName' })
  public color: Color;

  @Column({ type: 'varchar', length: 30 })
  public colorName: string;

  @Column({ type: 'text', array: true, default: [] })
  public imageUrls: string[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/productVariation_price.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  PrimaryGeneratedColumn,
  ManyToOne,
} from 'typeorm';
import { Country } from './country.entity';
import { Currency } from './currency.entity';
import { ProductVariation } from './productVariation.entity';

@Entity()
export class ProductVariationPrice {
  @PrimaryGeneratedColumn()
  public id!: number;

  @ManyToOne(() => ProductVariation)
  @JoinColumn({ name: 'productVariationId' })
  public productVariation: ProductVariation;

  @Column({ type: 'int' })
  public productVariationId: number;

  @ManyToOne(() => Country)
  @JoinColumn({ name: 'countryCode' })
  public country: Country;

  @Column({ type: 'varchar', length: 7 })
  public countryCode: string;

  @ManyToOne(() => Currency)
  @JoinColumn({ name: 'currencyCode' })
  public currency: Currency;

  @Column({ type: 'varchar', length: 7 })
  public currencyCode: string;

  @Column({ type: 'float' })
  public price: number;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/role.entity.ts

```typescript
import {
  Entity,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
  ManyToMany,
} from 'typeorm';
import { User } from './user.entity';

@Entity()
export class Role {
  @PrimaryColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public name: string;

  @ManyToMany(() => User, (user) => user.roles)
  public users: User[];

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/entities/size.entity.ts

```typescript
import {
  Entity,
  CreateDateColumn,
  UpdateDateColumn,
  PrimaryColumn,
} from 'typeorm';

@Entity()
export class Size {
  @PrimaryColumn({ type: 'varchar', length: 30 })
  public code!: string;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}

export enum SizeCodes {
  NA = 'NA',
  Small = 'S',
  Medium = 'M',
  Large = 'L',
  XLarge = 'XL',
  XXLarge = 'XXL',
}
```

## src/database/entities/user.entity.ts

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToMany,
  JoinTable,
  OneToMany,
} from 'typeorm';
import { Product } from './product.entity';
import { Role } from './role.entity';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  public id!: number;

  @Column({ type: 'varchar', length: 120, unique: true })
  public email: string;

  @Column({ type: 'varchar' })
  public password: string;

  @ManyToMany(() => Role, (role) => role.users)
  @JoinTable({ name: 'user_roles' })
  public roles: Role[];

  @OneToMany(() => Product, (product) => product.merchant)
  public products: Product;

  @CreateDateColumn({ type: 'timestamp' })
  public createdAt!: Date;

  @UpdateDateColumn({ type: 'timestamp' })
  public updatedAt!: Date;
}
```

## src/database/migration/datasource.ts

```typescript
import { DataSource } from 'typeorm';
import { dataSourceOptions } from '../typeorm/typeOrm.config';

const datasource = new DataSource(dataSourceOptions);

export default datasource;
```

## src/database/seed/seed.module.ts

```typescript
/* eslint-disable prettier/prettier */
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Category } from 'src/database/entities/category.entity';
import { Role } from 'src/database/entities/role.entity';
import { User } from 'src/database/entities/user.entity';
import { TypeOrmConfigService } from 'src/database/typeorm/typeorm.service';
import { Color } from '../entities/color.entity';
import { Country } from '../entities/country.entity';
import { Currency } from '../entities/currency.entity';
import { Size } from '../entities/size.entity';
import { SeedService } from './seed.service';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';
//  La importación 'configuration' ha sido eliminada

@Module({
  imports: [
    // Agregamos ConfigModule para que lea el .env al ejecutar seeds
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({ useClass: TypeOrmConfigService }),
    TypeOrmModule.forFeature([
      Role,
      User,
      Category,
      Size,
      Color,
      Country,
      Currency,
    ]),
  ],
  controllers: [],
  providers: [
    SeedService,
    RolesSeeder,
    AdminSeeder,
    CategorySeeder,
    SizeSeeder,
    ColorSeeder,
    CountrySeeder,
    CurrencySeeder,
  ],
})
export class SeedModule {}
```

## src/database/seed/seed.service.ts

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Promise as Bluebird } from 'bluebird';
import { SeederInterface } from './seeder.interface';
import { AdminSeeder } from './seeders/admin.seeder';
import { CategorySeeder } from './seeders/category.seeder';
import { ColorSeeder } from './seeders/color.seeder';
import { CountrySeeder } from './seeders/country.seeder';
import { CurrencySeeder } from './seeders/currency.seeder';
import { RolesSeeder } from './seeders/role.seeder';
import { SizeSeeder } from './seeders/size.seeder';

@Injectable()
export class SeedService {
  private readonly seeders: SeederInterface[] = [];
  private readonly logger = new Logger(SeedService.name);

  constructor(
    rolesSeeder: RolesSeeder,
    adminSeeder: AdminSeeder,
    categoriesSeeder: CategorySeeder,
    sizesSeeder: SizeSeeder,
    colorsSeeder: ColorSeeder,
    countrySeeder: CountrySeeder,
    currencySeeder: CurrencySeeder,
  ) {
    this.seeders = [
      rolesSeeder,
      adminSeeder,
      categoriesSeeder,
      sizesSeeder,
      colorsSeeder,
      countrySeeder,
      currencySeeder,
    ];
  }

  async seed() {
    await Bluebird.each(this.seeders, async (seeder: SeederInterface) => {
      this.logger.log(`Seeding ${seeder.constructor.name}`);
      await seeder.seed();
    });
  }
}
```

## src/database/seed/seed.ts

```typescript
import { NestFactory } from '@nestjs/core';
import { SeedModule } from './seed.module';
import { SeedService } from './seed.service';

async function bootstrap() {
  const app = await NestFactory.create(SeedModule);
  const seedService = app.get(SeedService);
  await seedService.seed();
  await app.close();
}
bootstrap();
```

## src/database/seed/seeder.interface.ts

```typescript
export interface SeederInterface {
  seed(): Promise<void>;
}
```

## src/database/seed/seeders/category.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Categories,
  Category,
  CategoryIds,
} from 'src/database/entities/category.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CategorySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Category)
    private readonly categoriesRepository: Repository<Category>,
  ) {}

  async seed() {
    const data: Partial<Category>[] = this.generateData();
    await this.categoriesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Category>[] {
    const data: Partial<Category>[] = [];
    Object.keys(Categories).forEach((key) => {
      data.push({
        id: CategoryIds[key],
        name: Categories[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/color.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Color,
  Colors,
  ColorsHexCodes,
} from 'src/database/entities/color.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class ColorSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Color)
    private readonly colorsRepository: Repository<Color>,
  ) {}

  async seed() {
    const data: Partial<Color>[] = this.generateData();
    await this.colorsRepository.upsert(data, {
      conflictPaths: ['name'],
    });
  }

  generateData(): Partial<Color>[] {
    const data: Partial<Color>[] = [];
    Object.keys(Colors).forEach((key) => {
      data.push({
        name: Colors[key],
        hexCode: ColorsHexCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/country.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Countries,
  Country,
  CountryCodes,
} from 'src/database/entities/country.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CountrySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Country)
    private readonly countryRepository: Repository<Country>,
  ) {}

  async seed() {
    const data: Partial<Country>[] = this.generateData();
    await this.countryRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Country>[] {
    const data: Partial<Country>[] = [];
    Object.keys(Countries).forEach((key) => {
      data.push({
        code: CountryCodes[key],
        name: Countries[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/currency.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  Currency,
  CurrencyCodes,
  CurrencyNames,
} from 'src/database/entities/currency.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class CurrencySeeder implements SeederInterface {
  constructor(
    @InjectRepository(Currency)
    private readonly currencyRepository: Repository<Currency>,
  ) {}

  async seed() {
    const data: Partial<Currency>[] = this.generateData();
    await this.currencyRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Currency>[] {
    const data: Partial<Currency>[] = [];
    Object.keys(CurrencyCodes).forEach((key) => {
      data.push({
        code: CurrencyCodes[key],
        name: CurrencyNames[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/role.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';
import { Role } from 'src/database/entities/role.entity';
import { RoleIds, Roles } from 'src/api/role/enum/role.enum';

@Injectable()
export class RolesSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Role)
    private readonly rolesRepository: Repository<Role>,
  ) {}

  async seed() {
    const data: Partial<Role>[] = this.generateData();
    await this.rolesRepository.upsert(data, {
      conflictPaths: ['id'],
    });
  }

  generateData(): Partial<Role>[] {
    const data: Partial<Role>[] = [];
    Object.keys(Roles).forEach((key) => {
      data.push({
        id: RoleIds[key],
        name: Roles[key],
      });
    });
    return data;
  }
}
```

## src/database/seed/seeders/size.seeder.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Size, SizeCodes } from 'src/database/entities/size.entity';
import { Repository } from 'typeorm';
import { SeederInterface } from '../seeder.interface';

@Injectable()
export class SizeSeeder implements SeederInterface {
  constructor(
    @InjectRepository(Size)
    private readonly SizeRepository: Repository<Size>,
  ) {}

  async seed() {
    const data: Partial<Size>[] = this.generateData();
    await this.SizeRepository.upsert(data, {
      conflictPaths: ['code'],
    });
  }

  generateData(): Partial<Size>[] {
    const data: Partial<Size>[] = [];
    Object.keys(SizeCodes).forEach((key) => {
      data.push({
        code: SizeCodes[key],
      });
    });
    return data;
  }
}
```

## src/database/typeorm/typeOrm.config.ts

```typescript
/* eslint-disable prettier/prettier */
import { DataSource, DataSourceOptions } from 'typeorm';
import { config } from 'dotenv';

// Carga .env solo si estamos en local y no en producción (donde ya existen las vars)
if (process.env.NODE_ENV !== 'production') {
  config(); 
}

export const dataSourceOptions: DataSourceOptions = {
  type: 'postgres',
  host: process.env.DATABASE_HOST,
  port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
  database: process.env.DATABASE_NAME,
  username: process.env.DATABASE_USER,
  password: process.env.DATABASE_PASSWORD,
  entities: ['dist/**/*.entity.js'], // Apuntamos a dist para producción
  migrations: ['dist/database/migration/history/*.js'],
  synchronize: false, 
  logging: process.env.NODE_ENV === 'development',
};

// Default export para CLI de TypeORM
const datasource = new DataSource(dataSourceOptions);
export default datasource;
```

## src/database/typeorm/typeorm.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import { TypeOrmOptionsFactory, TypeOrmModuleOptions } from '@nestjs/typeorm';
import { dataSourceOptions } from 'src/database/typeorm/typeOrm.config';

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  public createTypeOrmOptions(): TypeOrmModuleOptions {
    return dataSourceOptions;
  }
}
```

## src/errors/custom/index.ts

```typescript
export interface ErrorBody extends Error {
  code: string;
}
//corrijo errores de texto wronCredentials por wrongCredentials
//invlidToken por invalidToken
export const errorMessages = {
  auth: {
    wrongCredentials: {
      message: 'wrong data provided',
      code: '60001',
    },
    userAlreadyExist: {
      message: 'user already exist',
      code: '60002',
    },
    expiredToken: {
      message: 'token expired',
      code: '60003',
    },
    invalidToken: {
      message: 'invalid token',
      code: '60004',
    },
    notAllowed: {
      message: 'not allowed',
      code: '60005',
    },
  },
  user: {
    notFound: {
      message: 'user not found',
      code: '60101',
    },
  },
  role: {
    notFound: {
      message: 'role not found',
      code: '60201',
    },
  },
  category: {
    notFound: {
      message: 'category not found',
      code: '60301',
    },
  },
  product: {
    notFound: {
      message: 'product not found',
      code: '60401',
    },
    notFulfilled: {
      message: 'not all product info is fulfilled',
      code: '60402',
    },
  },
  global: {
    internalError: {
      message: 'something went wrong',
      code: '70000',
    },
  },
};
```

## src/errors/errors.filter.ts

```typescript
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';
import { ErrorBody, errorMessages } from './custom';

@Catch()
export class ErrorsFilter implements ExceptionFilter {
  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

  catch(exception: Error, host: ArgumentsHost): void {
    Logger.error(exception.message);
    const { httpAdapter } = this.httpAdapterHost;

    const ctx = host.switchToHttp();
    if (exception instanceof HttpException) {
      const message = exception.message;
      const httpStatus =
        exception.getStatus() || HttpStatus.INTERNAL_SERVER_ERROR;
      const errorMessage = (exception.getResponse() as HttpException).message;
      const errorCode = (exception.getResponse() as ErrorBody).code || '60400';
      const errors = Array.isArray(errorMessage)
        ? errorMessage
        : [errorMessage];
      const responseBody = {
        isSuccess: false,
        message,
        errorCode,
        data: null,
        errors,
      };

      httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);
    } else {
      const responseBody = {
        isSuccess: false,
        message: errorMessages.global.internalError.message,
        errorCode: errorMessages.global.internalError.code,
        data: null,
        errors: [errorMessages.global.internalError.message],
      };

      httpAdapter.reply(
        ctx.getResponse(),
        responseBody,
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
```

## src/main.ts

```typescript
/* eslint-disable prettier/prettier */
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // 1. Habilitar CORS (Justificación: Permite que el Front en localhost:5173 acceda a la API)
  app.enableCors({
    origin: 'http://localhost:5173', // URL por defecto de Vite
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  });

  // 2. Global Prefix (Opcional pero recomendado para Sr.)
  app.setGlobalPrefix('api');

  // 3. Pipes de Validación
  app.useGlobalPipes(new ValidationPipe({ 
    transform: true,
    whitelist: true, // Ignora propiedades que no esten en el DTO
    forbidNonWhitelisted: true, // Lanza error si envían datos de mas
  }));

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}

bootstrap();
```

## Statistics

- Total Files: 72
- Total Characters: 452466
- Total Tokens: 0
